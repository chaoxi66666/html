<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸“å®¶çº§Pythonå·¥å…·ç³»ç»Ÿ</title>
    <style>
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-size: 13px;
        }
        h1, h2 { 
            margin: 15px 0 10px 0; 
            color: #569cd6;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 5px;
        }
        h1 { 
            color: #d7ba7d; 
            text-align: center;
            margin-top: 0;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        .sidebar {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
        }
        .main-content {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
        }
        .tool-category {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3e3e42;
        }
        .tool-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            color: #d4d4d4;
        }
        .tool-item:hover {
            background: #3e3e42;
            border-color: #007acc;
        }
        .tool-item.active {
            background: #0e639c;
            border-color: #007acc;
        }
        .tool-section {
            display: none;
        }
        .tool-section.active {
            display: block;
        }
        textarea, input, select {
            width: 100%;
            padding: 8px;
            margin: 5px 0 15px 0;
            background: #252526;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 3px;
            font-family: inherit;
            font-size: 13px;
        }
        textarea {
            min-height: 200px;
            resize: vertical;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }
        button:hover {
            background: #106ebe;
        }
        button.secondary {
            background: #4d4d4d;
        }
        button.secondary:hover {
            background: #5d5d5d;
        }
        .code-editor {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.4;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            tab-size: 4;
        }
        .output {
            background: #0c0c0c;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            padding: 15px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            margin-top: 15px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .error { color: #f44747; }
        .warning { color: #ffcc00; }
        .success { color: #6a9955; }
        .info { color: #569cd6; }
        .keyword { color: #c586c0; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .comment { color: #6a9955; }
        .flex-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-running { background: #ffcc00; }
        .status-success { background: #6a9955; }
        .status-error { background: #f44747; }
        .tool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .tool-description {
            color: #858585;
            font-size: 12px;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .highlight {
            background: rgba(86, 156, 214, 0.1);
            border-left: 3px solid #569cd6;
            padding: 10px;
            margin: 10px 0;
        }
        .dependency-list {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
        }
        .dependency-item {
            padding: 5px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
        }
        .dependency-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <h1>ğŸ ä¸“å®¶çº§Pythonå·¥å…·ç³»ç»Ÿ</h1>
    
    <div class="container">
        <!-- ä¾§è¾¹æ  -->
        <div class="sidebar">
            <div class="tool-category">
                <h2>ğŸ” ä»£ç åˆ†æ</h2>
                <div class="tool-item active" onclick="showTool('ast-analyzer')">ASTä»£ç åˆ†æå™¨</div>
                <div class="tool-item" onclick="showTool('complexity-checker')">å¤æ‚åº¦æ£€æŸ¥å™¨</div>
                <div class="tool-item" onclick="showTool('type-checker')">ç±»å‹æ£€æŸ¥æ¨¡æ‹Ÿå™¨</div>
                <div class="tool-item" onclick="showTool('security-scanner')">å®‰å…¨æ¼æ´æ‰«æå™¨</div>
            </div>
            
            <div class="tool-category">
                <h2>âš¡ æ€§èƒ½å·¥å…·</h2>
                <div class="tool-item" onclick="showTool('profiler')">æ€§èƒ½åˆ†æå™¨</div>
                <div class="tool-item" onclick="showTool('memory-analyzer')">å†…å­˜åˆ†æå™¨</div>
                <div class="tool-item" onclick="showTool('concurrency-checker')">å¹¶å‘å®‰å…¨æ£€æŸ¥</div>
            </div>
            
            <div class="tool-category">
                <h2>ğŸ› ï¸ ä»£ç ç”Ÿæˆ</h2>
                <div class="tool-item" onclick="showTool('class-generator')">ç±»ç”Ÿæˆå™¨</div>
                <div class="tool-item" onclick="showTool('api-generator')">APIä»£ç ç”Ÿæˆå™¨</div>
                <div class="tool-item" onclick="showTool('test-generator')">æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå™¨</div>
                <div class="tool-item" onclick="showTool('orm-generator')">ORMæ¨¡å‹ç”Ÿæˆå™¨</div>
            </div>
            
            <div class="tool-category">
                <h2>ğŸ”§ å·¥å…·é›†</h2>
                <div class="tool-item" onclick="showTool('dependency-analyzer')">ä¾èµ–åˆ†æå™¨</div>
                <div class="tool-item" onclick="showTool('error-simulator')">é”™è¯¯æ¨¡æ‹Ÿå™¨</div>
                <div class="tool-item" onclick="showTool('code-metrics')">ä»£ç åº¦é‡å·¥å…·</div>
                <div class="tool-item" onclick="showTool('pattern-detector')">è®¾è®¡æ¨¡å¼æ£€æµ‹å™¨</div>
            </div>
            
            <div class="tool-category">
                <h2>ğŸ“Š ä¼˜åŒ–å·¥å…·</h2>
                <div class="tool-item" onclick="showTool('performance-optimizer')">æ€§èƒ½ä¼˜åŒ–å™¨</div>
                <div class="tool-item" onclick="showTool('import-optimizer')">å¯¼å…¥ä¼˜åŒ–å™¨</div>
                <div class="tool-item" onclick="showTool('cache-optimizer')">ç¼“å­˜ä¼˜åŒ–å™¨</div>
            </div>
        </div>
        
        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- ASTä»£ç åˆ†æå™¨ -->
            <div id="ast-analyzer" class="tool-section active">
                <div class="tool-header">
                    <h2>ğŸ” ASTä»£ç åˆ†æå™¨</h2>
                    <button onclick="analyzeAST()">åˆ†æä»£ç </button>
                </div>
                <div class="tool-description">
                    ä½¿ç”¨Pythonçš„ASTæ¨¡å—è§£æä»£ç ï¼Œæ£€æŸ¥è¯­æ³•ç»“æ„ï¼Œè¯†åˆ«æ½œåœ¨é—®é¢˜ï¼Œå¹¶æä¾›é‡æ„å»ºè®®ã€‚
                </div>
                <textarea id="ast-code" placeholder="è¾“å…¥Pythonä»£ç è¿›è¡ŒASTåˆ†æ...">
def calculate_factorial(n: int) -> int:
    """è®¡ç®—é˜¶ä¹˜"""
    if n < 0:
        raise ValueError("é˜¶ä¹˜ä¸èƒ½ä¸ºè´Ÿæ•°")
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

def process_data(data: list) -> dict:
    """å¤„ç†æ•°æ®å¹¶è¿”å›ç»Ÿè®¡ä¿¡æ¯"""
    if not data:
        return {}
    
    stats = {
        'count': len(data),
        'sum': sum(data),
        'mean': sum(data) / len(data) if data else 0,
        'max': max(data) if data else 0
    }
    
    # æ½œåœ¨çš„é”™è¯¯ï¼šæœªå¤„ç†å¼‚å¸¸æƒ…å†µ
    for item in data:
        if item > 1000:
            print(f"å¤§æ•°å€¼: {item}")
    
    return stats

# å¤æ‚åµŒå¥—å‡½æ•°ç¤ºä¾‹
def complex_function(x, y):
    def inner_func(a):
        return a * 2
    
    if x > y:
        return inner_func(x) + y
    else:
        return x - inner_func(y)</textarea>
                <div class="output" id="ast-output"></div>
            </div>
            
            <!-- å¤æ‚åº¦æ£€æŸ¥å™¨ -->
            <div id="complexity-checker" class="tool-section">
                <div class="tool-header">
                    <h2>âš™ï¸ ä»£ç å¤æ‚åº¦æ£€æŸ¥å™¨</h2>
                    <button onclick="checkComplexity()">æ£€æŸ¥å¤æ‚åº¦</button>
                </div>
                <div class="tool-description">
                    è®¡ç®—åœˆå¤æ‚åº¦ã€è®¤çŸ¥å¤æ‚åº¦ï¼Œè¯†åˆ«è¿‡åº¦å¤æ‚çš„ä»£ç æ®µï¼Œå¹¶æä¾›ç®€åŒ–å»ºè®®ã€‚
                </div>
                <textarea id="complexity-code" placeholder="è¾“å…¥Pythonä»£ç è¿›è¡Œå¤æ‚åº¦åˆ†æ...">
class DataProcessor:
    def __init__(self, config):
        self.config = config
        self.data = []
        self.results = {}
    
    def process(self, input_data):
        """è¿‡åº¦å¤æ‚çš„æ–¹æ³•ç¤ºä¾‹"""
        if not input_data:
            return None
        
        # å¤šå±‚åµŒå¥—æ¡ä»¶åˆ¤æ–­
        if isinstance(input_data, list):
            if len(input_data) > 0:
                for item in input_data:
                    if isinstance(item, dict):
                        for key, value in item.items():
                            if key in self.config:
                                if value is not None:
                                    if isinstance(value, (int, float)):
                                        if value > self.config[key]:
                                            self.data.append(value)
                                            if len(self.data) > 100:
                                                return self.data
                                    elif isinstance(value, str):
                                        if len(value) > 10:
                                            self.data.append(value)
            else:
                return []
        elif isinstance(input_data, dict):
            # å¦ä¸€ä¸ªå¤æ‚çš„æ¡ä»¶åˆ†æ”¯
            pass
        
        # å¤šå±‚å¾ªç¯åµŒå¥—
        for i in range(10):
            for j in range(10):
                for k in range(10):
                    if i * j * k > 100:
                        for m in range(5):
                            if m % 2 == 0:
                                print(i, j, k, m)
        
        return self.data
    
    def calculate_metrics(self, data):
        """è®¤çŸ¥å¤æ‚åº¦é«˜çš„æ–¹æ³•"""
        try:
            if data:
                if len(data) > 0:
                    result = []
                    for item in data:
                        if item:
                            if isinstance(item, dict):
                                for key, value in item.items():
                                    if value:
                                        if isinstance(value, list):
                                            for subitem in value:
                                                if subitem:
                                                    result.append(subitem)
                                        else:
                                            result.append(value)
                    return sum(result) if result else 0
        except Exception as e:
            print(f"é”™è¯¯: {e}")
        return None</textarea>
                <div class="output" id="complexity-output"></div>
            </div>
            
            <!-- ç±»å‹æ£€æŸ¥æ¨¡æ‹Ÿå™¨ -->
            <div id="type-checker" class="tool-section">
                <div class="tool-header">
                    <h2>ğŸ”¬ ç±»å‹æ£€æŸ¥æ¨¡æ‹Ÿå™¨</h2>
                    <button onclick="checkTypes()">ç±»å‹æ£€æŸ¥</button>
                </div>
                <div class="tool-description">
                    æ¨¡æ‹ŸPythonç±»å‹æ£€æŸ¥ï¼Œè¯†åˆ«ç±»å‹é”™è¯¯ã€ä¸ä¸€è‡´çš„ç±»å‹æ³¨è§£å’Œæ½œåœ¨çš„è¿è¡Œæ—¶ç±»å‹é”™è¯¯ã€‚
                </div>
                <div class="grid-2">
                    <div>
                        <textarea id="type-code" placeholder="è¾“å…¥å¸¦æœ‰ç±»å‹æ³¨è§£çš„Pythonä»£ç ...">
from typing import Optional, List, Dict, Union, Any
import datetime

def process_user_data(
    user_id: int,
    data: Dict[str, Any],
    options: Optional[Dict] = None
) -> Union[Dict, None]:
    """å¤„ç†ç”¨æˆ·æ•°æ®"""
    # æ½œåœ¨çš„ç±»å‹é”™è¯¯
    result = {}
    
    if not data:
        return None
    
    # ç±»å‹ä¸ä¸€è‡´
    name = data.get("name", "")
    age = data.get("age", "0")  # åº”è¯¥æ˜¯intï¼Œä½†é»˜è®¤ä¸ºstr
    
    # é”™è¯¯çš„ç±»å‹æ“ä½œ
    if age > 18:  # å­—ç¬¦ä¸²å’Œæ•°å­—æ¯”è¾ƒ
        result["adult"] = True
    
    # ç±»å‹è½¬æ¢é—®é¢˜
    try:
        registration_date = datetime.datetime.fromisoformat(
            data.get("registered", "")
        )
    except ValueError:
        registration_date = None
    
    # è¿”å›ç±»å‹ä¸ä¸€è‡´
    if options and options.get("detailed"):
        return {
            "id": user_id,
            "name": name,
            "age": int(age) if age.isdigit() else 0,
            "registered": registration_date
        }
    else:
        return str(user_id)  # åº”è¯¥è¿”å›Dictï¼Œä½†è¿”å›äº†str

def calculate_stats(numbers: List[int]) -> Dict[str, float]:
    """è®¡ç®—ç»Ÿè®¡æ•°æ®"""
    if not numbers:
        return {}  # åº”è¯¥è¿”å›Dict[str, float]ï¼Œä½†è¿”å›äº†ç©ºdict
    
    # æ··åˆç±»å‹æ“ä½œ
    total = sum(numbers)
    count = len(numbers)
    
    # æ½œåœ¨çš„ç±»å‹é—®é¢˜
    mean = total / count if count > 0 else 0.0
    
    return {
        "total": total,
        "count": count,
        "mean": mean,
        "max": max(numbers) if numbers else 0
    }

class DataProcessor:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.cache: Dict[int, Any] = {}
    
    def process(self, data: Any) -> Any:
        """å¤„ç†æ•°æ®"""
        # è¿‡äºå®½æ³›çš„ç±»å‹æ³¨è§£
        if isinstance(data, list):
            return [self.process(item) for item in data]
        elif isinstance(data, dict):
            return {k: self.process(v) for k, v in data.items()}
        else:
            return str(data)  # ä»»æ„ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²</textarea>
                    </div>
                    <div>
                        <div class="output" id="type-output"></div>
                    </div>
                </div>
            </div>
            
            <!-- å®‰å…¨æ¼æ´æ‰«æå™¨ -->
            <div id="security-scanner" class="tool-section">
                <div class="tool-header">
                    <h2>ğŸ›¡ï¸ å®‰å…¨æ¼æ´æ‰«æå™¨</h2>
                    <button onclick="scanSecurity()">æ‰«æå®‰å…¨æ¼æ´</button>
                </div>
                <div class="tool-description">
                    æ£€æµ‹å¸¸è§å®‰å…¨æ¼æ´ï¼šSQLæ³¨å…¥ã€å‘½ä»¤æ³¨å…¥ã€XSSã€æ–‡ä»¶æ“ä½œæ¼æ´ã€ç¡¬ç¼–ç å‡­è¯ç­‰ã€‚
                </div>
                <textarea id="security-code" placeholder="è¾“å…¥Pythonä»£ç è¿›è¡Œå®‰å…¨æ‰«æ...">
import os
import subprocess
import sqlite3
from flask import Flask, request, render_template_string

app = Flask(__name__)

# ç¡¬ç¼–ç å‡­è¯
DATABASE_PASSWORD = "supersecret123"
API_KEY = "1234567890abcdef"

# SQLæ³¨å…¥æ¼æ´
def get_user_data(user_id):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # å±é™©çš„SQLæ‹¼æ¥
    query = f"SELECT * FROM users WHERE id = {user_id}"
    cursor.execute(query)  # SQLæ³¨å…¥é£é™©ï¼
    
    # å¦ä¸€ä¸ªæœ‰é£é™©çš„æŸ¥è¯¢
    username = request.args.get('username')
    query2 = "SELECT * FROM users WHERE username = '%s'" % username
    cursor.execute(query2)
    
    return cursor.fetchall()

# å‘½ä»¤æ³¨å…¥æ¼æ´
def execute_system_command(command):
    # ç›´æ¥æ‰§è¡Œç”¨æˆ·è¾“å…¥çš„å‘½ä»¤
    result = os.system(command)  # å‘½ä»¤æ³¨å…¥é£é™©ï¼
    return result

def run_backup(backup_name):
    # ä½¿ç”¨shell=Trueä¸”æœªæ¸…ç†è¾“å…¥
    cmd = f"tar -czf /backups/{backup_name}.tar.gz /data"
    subprocess.run(cmd, shell=True)  # å‘½ä»¤æ³¨å…¥é£é™©ï¼
    return True

# è·¯å¾„éå†æ¼æ´
def read_file(filename):
    # æœªéªŒè¯çš„æ–‡ä»¶è·¯å¾„
    with open(f"/data/{filename}", "r") as f:  # è·¯å¾„éå†é£é™©ï¼
        return f.read()

# XSSæ¼æ´
@app.route('/search')
def search():
    query = request.args.get('q', '')
    # æœªè½¬ä¹‰çš„ç”¨æˆ·è¾“å…¥
    html = f"<h1>æœç´¢ç»“æœ: {query}</h1>"
    return render_template_string(html)  # XSSé£é™©ï¼

# ååºåˆ—åŒ–æ¼æ´
import pickle
import json

def load_config(config_data):
    # ä¸å®‰å…¨çš„ååºåˆ—åŒ–
    config = pickle.loads(config_data)  # ååºåˆ—åŒ–é£é™©ï¼
    return config

def load_json_data(json_str):
    # ä½¿ç”¨æœ‰é£é™©çš„å¯¹è±¡é’©å­
    data = json.loads(json_str, object_hook=lambda d: type('X', (object,), d)())
    return data

# ä¸å®‰å…¨çš„éšæœºæ•°
import random

def generate_token():
    # ä½¿ç”¨ä¸å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
    token = random.randint(100000, 999999)  # å¯†ç å­¦ä¸Šä¸å®‰å…¨çš„éšæœºæ•°ï¼
    return str(token)

# ç¡¬ç¼–ç å¯†é’¥
SECRET_KEY = b'this_is_a_very_secret_key'  # ç¡¬ç¼–ç å¯†é’¥ï¼

# ä¿¡æ¯æ³„éœ²
def debug_info():
    # ç”Ÿäº§ç¯å¢ƒä¸åº”æš´éœ²è°ƒè¯•ä¿¡æ¯
    import sys
    debug_data = {
        'python_version': sys.version,
        'path': sys.path,
        'modules': list(sys.modules.keys())
    }
    return str(debug_data)  # ä¿¡æ¯æ³„éœ²é£é™©ï¼</textarea>
                <div class="output" id="security-output"></div>
            </div>
            
            <!-- æ€§èƒ½åˆ†æå™¨ -->
            <div id="profiler" class="tool-section">
                <div class="tool-header">
                    <h2>âš¡ æ€§èƒ½åˆ†æå™¨</h2>
                    <button onclick="analyzePerformance()">åˆ†ææ€§èƒ½</button>
                </div>
                <div class="tool-description">
                    æ¨¡æ‹Ÿä»£ç æ€§èƒ½åˆ†æï¼Œè¯†åˆ«æ€§èƒ½ç“¶é¢ˆï¼Œæä¾›ä¼˜åŒ–å»ºè®®ã€‚
                </div>
                <textarea id="performance-code" placeholder="è¾“å…¥Pythonä»£ç è¿›è¡Œæ€§èƒ½åˆ†æ...">
import time
from functools import lru_cache

# æ€§èƒ½é—®é¢˜ç¤ºä¾‹
def inefficient_fibonacci(n):
    """ä½æ•ˆçš„æ–æ³¢é‚£å¥‘æ•°åˆ—å®ç°"""
    if n <= 1:
        return n
    return inefficient_fibonacci(n-1) + inefficient_fibonacci(n-2)

def process_large_list(data):
    """å¤„ç†å¤§åˆ—è¡¨çš„æ€§èƒ½é—®é¢˜"""
    result = []
    
    # ä½æ•ˆçš„å¾ªç¯
    for i in range(len(data)):
        for j in range(len(data)):
            if data[i] == data[j] and i != j:
                result.append((i, j))
    
    # ä¸å¿…è¦çš„é‡å¤è®¡ç®—
    squares = []
    for item in data:
        squares.append(item ** 2)
    
    cubes = []
    for item in data:
        cubes.append(item ** 3)
    
    return result, squares, cubes

def string_concatenation_example(items):
    """å­—ç¬¦ä¸²æ‹¼æ¥çš„æ€§èƒ½é—®é¢˜"""
    result = ""
    for item in items:
        result += str(item)  # ä½æ•ˆçš„å­—ç¬¦ä¸²æ‹¼æ¥
    return result

def database_query_simulation(n):
    """æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢çš„N+1é—®é¢˜"""
    results = []
    for i in range(n):
        # æ¨¡æ‹Ÿå•ç‹¬çš„æŸ¥è¯¢ï¼ˆN+1é—®é¢˜ï¼‰
        time.sleep(0.01)  # æ¨¡æ‹ŸæŸ¥è¯¢å»¶è¿Ÿ
        results.append(f"Result {i}")
    return results

# ä¼˜åŒ–ç‰ˆæœ¬ç¤ºä¾‹
@lru_cache(maxsize=128)
def efficient_fibonacci(n):
    """ä½¿ç”¨ç¼“å­˜ä¼˜åŒ–çš„æ–æ³¢é‚£å¥‘æ•°åˆ—"""
    if n <= 1:
        return n
    return efficient_fibonacci(n-1) + efficient_fibonacci(n-2)

def optimized_process(data):
    """ä¼˜åŒ–çš„åˆ—è¡¨å¤„ç†"""
    # ä½¿ç”¨é›†åˆæé«˜æŸ¥æ‰¾æ•ˆç‡
    seen = set()
    duplicates = []
    
    for i, item in enumerate(data):
        if item in seen:
            duplicates.append(i)
        seen.add(item)
    
    # ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼
    squares = [x ** 2 for x in data]
    cubes = [x ** 3 for x in data]
    
    return duplicates, squares, cubes

def efficient_string_join(items):
    """é«˜æ•ˆçš„å­—ç¬¦ä¸²æ‹¼æ¥"""
    return "".join(str(item) for item in items)

class DataProcessor:
    def __init__(self):
        self.cache = {}
    
    def heavy_computation(self, x):
        """é‡è®¡ç®—å‡½æ•°"""
        if x in self.cache:
            return self.cache[x]
        
        # æ¨¡æ‹Ÿé‡è®¡ç®—
        result = sum(i * x for i in range(10000))
        self.cache[x] = result
        return result</textarea>
                <div class="output" id="performance-output"></div>
            </div>
            
            <!-- ç±»ç”Ÿæˆå™¨ -->
            <div id="class-generator" class="tool-section">
                <div class="tool-header">
                    <h2>ğŸ—ï¸ ç±»ç”Ÿæˆå™¨</h2>
                    <button onclick="generateClass()">ç”Ÿæˆç±»</button>
                </div>
                <div class="tool-description">
                    æ ¹æ®éœ€æ±‚è‡ªåŠ¨ç”ŸæˆPythonç±»ï¼ŒåŒ…æ‹¬å±æ€§ã€æ–¹æ³•ã€ç±»å‹æ³¨è§£ã€æ–‡æ¡£å­—ç¬¦ä¸²ç­‰ã€‚
                </div>
                <div class="grid-2">
                    <div>
                        <h3>ç±»é…ç½®</h3>
                        <input type="text" id="class-name" placeholder="ç±»å" value="User">
                        <textarea id="class-properties" placeholder="å±æ€§é…ç½® (æ¯è¡Œ: name:type=default)">
name:str
age:int=0
email:Optional[str]=None
is_active:bool=True
permissions:List[str]=None</textarea>
                        <textarea id="class-methods" placeholder="æ–¹æ³•é…ç½® (æ¯è¡Œ: name:return_type:description)">
get_full_info:dict:è·å–ç”¨æˆ·å®Œæ•´ä¿¡æ¯
activate:bool:æ¿€æ´»ç”¨æˆ·è´¦æˆ·
add_permission:None:æ·»åŠ æƒé™
validate_email:bool:éªŒè¯é‚®ç®±æ ¼å¼</textarea>
                        <select id="class-features">
                            <option value="basic">åŸºç¡€ç±»</option>
                            <option value="dataclass">æ•°æ®ç±»</option>
                            <option value="pydantic">Pydanticæ¨¡å‹</option>
                            <option value="full">å®Œæ•´ç±»ï¼ˆåŒ…å«é­”æœ¯æ–¹æ³•ï¼‰</option>
                        </select>
                    </div>
                    <div>
                        <div class="output" id="class-output"></div>
                    </div>
                </div>
            </div>
            
            <!-- APIä»£ç ç”Ÿæˆå™¨ -->
            <div id="api-generator" class="tool-section">
                <div class="tool-header">
                    <h2>ğŸŒ APIä»£ç ç”Ÿæˆå™¨</h2>
                    <button onclick="generateAPI()">ç”ŸæˆAPIä»£ç </button>
                </div>
                <div class="tool-description">
                    æ ¹æ®OpenAPIè§„èŒƒæˆ–ç®€å•é…ç½®ç”ŸæˆFastAPI/Flask APIä»£ç ã€‚
                </div>
                <div class="grid-2">
                    <div>
                        <h3>APIé…ç½®</h3>
                        <select id="api-framework">
                            <option value="fastapi">FastAPI</option>
                            <option value="flask">Flask</option>
                        </select>
                        <textarea id="api-endpoints" placeholder="ç«¯ç‚¹é…ç½® (JSONæ ¼å¼)">
[
    {
        "path": "/users",
        "methods": ["GET", "POST"],
        "summary": "ç”¨æˆ·ç®¡ç†",
        "params": [
            {"name": "user_id", "type": "int", "required": false, "location": "query"},
            {"name": "user_data", "type": "UserCreate", "required": true, "location": "body"}
        ],
        "responses": {
            "200": {"description": "æˆåŠŸ", "type": "List[User]"},
            "201": {"description": "åˆ›å»ºæˆåŠŸ", "type": "User"}
        }
    },
    {
        "path": "/users/{user_id}",
        "methods": ["GET", "PUT", "DELETE"],
        "summary": "ç”¨æˆ·æ“ä½œ",
        "params": [
            {"name": "user_id", "type": "int", "required": true, "location": "path"}
        ],
        "responses": {
            "200": {"description": "æˆåŠŸ", "type": "User"},
            "404": {"description": "ç”¨æˆ·ä¸å­˜åœ¨"}
        }
    }
]</textarea>
                        <textarea id="api-models" placeholder="æ•°æ®æ¨¡å‹ (æ¯è¡Œä¸€ä¸ªæ¨¡å‹)">
UserCreate:name:str,email:str,password:str,age:Optional[int]=None
UserResponse:user_id:int,name:str,email:str,age:Optional[int],created_at:datetime
ErrorResponse:detail:str,code:int,timestamp:datetime</textarea>
                    </div>
                    <div>
                        <div class="output" id="api-output"></div>
                    </div>
                </div>
            </div>
            
            <!-- ä¾èµ–åˆ†æå™¨ -->
            <div id="dependency-analyzer" class="tool-section">
                <div class="tool-header">
                    <h2>ğŸ“¦ ä¾èµ–åˆ†æå™¨</h2>
                    <button onclick="analyzeDependencies()">åˆ†æä¾èµ–</button>
                </div>
                <div class="tool-description">
                    åˆ†æPythonä»£ç çš„å¯¼å…¥ä¾èµ–å…³ç³»ï¼Œæ£€æµ‹å¾ªç¯å¯¼å…¥ã€æœªä½¿ç”¨å¯¼å…¥ã€ç‰ˆæœ¬å†²çªç­‰é—®é¢˜ã€‚
                </div>
                <textarea id="dependency-code" placeholder="è¾“å…¥åŒ…å«å¯¼å…¥çš„Pythonä»£ç ...">
import os
import sys
from typing import List, Dict, Optional, Union
import datetime
from datetime import timedelta
import json
import csv
import re
import math
from collections import defaultdict, Counter
import itertools
from functools import lru_cache, wraps

# æœªä½¿ç”¨çš„å¯¼å…¥
import random  # æœªä½¿ç”¨
import string  # æœªä½¿ç”¨

# å¾ªç¯å¯¼å…¥é£é™©ç¤ºä¾‹
# from models import User  # å¯èƒ½å¯¼è‡´å¾ªç¯å¯¼å…¥
# from services.user_service import get_user

# æ¨¡ç³Šå¯¼å…¥
from utils import *  # åº”è¯¥é¿å…çš„æ¨¡ç³Šå¯¼å…¥

# ç›¸å¯¹å¯¼å…¥ï¼ˆæ¨¡æ‹Ÿï¼‰
# from .config import settings
# from ..database import connection

import requests
import numpy as np
import pandas as pd
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# ç‰ˆæœ¬å†²çªé£é™©çš„å¯¼å…¥
import tensorflow as tf  # å¯èƒ½éœ€è¦ç‰¹å®šç‰ˆæœ¬
import torch

# è¿‡æ—¶çš„å¯¼å…¥
import md5  # Python 2çš„æ¨¡å—ï¼ŒPython 3ä¸­å·²ç§»é™¤
import urllib2  # Python 2çš„æ¨¡å—

# æ ‡å‡†åº“ä¸­çš„é‡å¤å¯¼å…¥
import datetime  # å·²å¯¼å…¥
from time import time, sleep

# ç¬¬ä¸‰æ–¹åº“çš„ç‰ˆæœ¬æ£€æŸ¥
try:
    import django
    DJANGO_VERSION = django.get_version()
except ImportError:
    DJANGO_VERSION = None

# æ¡ä»¶å¯¼å…¥
if sys.platform == "win32":
    import winreg  # Windowsç‰¹å®š
else:
    import pwd  # Unixç‰¹å®š

# åˆ«åå¯¼å…¥
import matplotlib.pyplot as plt
import seaborn as sns

class DataProcessor:
    def __init__(self):
        self.engine = None
    
    def setup_database(self):
        """è®¾ç½®æ•°æ®åº“è¿æ¥"""
        from sqlalchemy import MetaData  # å±€éƒ¨å¯¼å…¥
        from sqlalchemy.orm import scoped_session
        
        # åŠ¨æ€å¯¼å…¥
        import config
        self.engine = create_engine(config.DATABASE_URL)</textarea>
                <div class="output" id="dependency-output"></div>
            </div>
            
            <!-- é”™è¯¯æ¨¡æ‹Ÿå™¨ -->
            <div id="error-simulator" class="tool-section">
                <div class="tool-header">
                    <h2>âš ï¸ é”™è¯¯æ¨¡æ‹Ÿå™¨</h2>
                    <select id="error-type">
                        <option value="syntax">è¯­æ³•é”™è¯¯</option>
                        <option value="type">ç±»å‹é”™è¯¯</option>
                        <option value="import">å¯¼å…¥é”™è¯¯</option>
                        <option value="attribute">å±æ€§é”™è¯¯</option>
                        <option value="key">é”®é”™è¯¯</option>
                        <option value="index">ç´¢å¼•é”™è¯¯</option>
                        <option value="value">å€¼é”™è¯¯</option>
                        <option value="name">åç§°é”™è¯¯</option>
                        <option value="recursion">é€’å½’é”™è¯¯</option>
                        <option value="memory">å†…å­˜é”™è¯¯</option>
                        <option value="all">æ‰€æœ‰å¸¸è§é”™è¯¯</option>
                    </select>
                    <button onclick="simulateError()">æ¨¡æ‹Ÿé”™è¯¯</button>
                </div>
                <div class="tool-description">
                    ç”ŸæˆåŒ…å«ç‰¹å®šé”™è¯¯çš„Pythonä»£ç ï¼Œå¸®åŠ©å­¦ä¹ å’Œè°ƒè¯•å¸¸è§Pythoné”™è¯¯ã€‚
                </div>
                <div class="output" id="error-output"></div>
            </div>
        </div>
    </div>

    <script>
        // å·¥å…·åˆ‡æ¢
        function showTool(toolId) {
            document.querySelectorAll('.tool-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.tool-item').forEach(item => {
                item.classList.remove('active');
            });
            
            document.getElementById(toolId).classList.add('active');
            event.target.classList.add('active');
        }

        // ASTä»£ç åˆ†æå™¨
        function analyzeAST() {
            const code = document.getElementById('ast-code').value;
            const output = document.getElementById('ast-output');
            
            let result = "ğŸ” ASTåˆ†ææŠ¥å‘Š\n\n";
            
            try {
                // æ¨¡æ‹ŸASTåˆ†æ
                const lines = code.split('\n');
                let indentLevel = 0;
                let functionCount = 0;
                let classCount = 0;
                let complexityScore = 0;
                let issues = [];
                
                result += "ğŸ“Š ä»£ç ç»Ÿè®¡:\n";
                result += "â”€".repeat(40) + "\n";
                result += `è¡Œæ•°: ${lines.length}\n`;
                
                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    
                    // ç»Ÿè®¡å‡½æ•°
                    if (trimmed.startsWith('def ')) {
                        functionCount++;
                        result += `å‡½æ•°å®šä¹‰: ${trimmed.split('def ')[1].split('(')[0]} (ç¬¬${index + 1}è¡Œ)\n`;
                    }
                    
                    // ç»Ÿè®¡ç±»
                    if (trimmed.startsWith('class ')) {
                        classCount++;
                        result += `ç±»å®šä¹‰: ${trimmed.split('class ')[1].split(':')[0]} (ç¬¬${index + 1}è¡Œ)\n`;
                    }
                    
                    // æ£€æŸ¥ç¼©è¿›
                    const currentIndent = line.length - line.trimStart().length;
                    if (currentIndent % 4 !== 0 && trimmed) {
                        issues.push(`ç¬¬${index + 1}è¡Œ: ç¼©è¿›ä¸æ˜¯4çš„å€æ•°`);
                    }
                    
                    // æ£€æŸ¥å¤æ‚åº¦
                    if (trimmed.includes('if ') || trimmed.includes('for ') || 
                        trimmed.includes('while ') || trimmed.includes('except ')) {
                        complexityScore++;
                    }
                });
                
                result += `\næ€»å‡½æ•°æ•°: ${functionCount}\n`;
                result += `æ€»ç±»æ•°: ${classCount}\n`;
                result += `å¤æ‚åº¦åˆ†æ•°: ${complexityScore}\n\n`;
                
                // ç»“æ„åˆ†æ
                result += "ğŸ—ï¸ ä»£ç ç»“æ„åˆ†æ:\n";
                result += "â”€".repeat(40) + "\n";
                
                let currentFunction = null;
                let nestLevel = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    if (trimmed.startsWith('def ')) {
                        currentFunction = trimmed.split('def ')[1].split('(')[0];
                        result += `\nå‡½æ•° "${currentFunction}":\n`;
                        nestLevel = 0;
                    } else if (trimmed.startsWith('class ')) {
                        currentFunction = null;
                        result += `\nç±» "${trimmed.split('class ')[1].split(':')[0]}":\n`;
                    }
                    
                    if (currentFunction && trimmed) {
                        if (trimmed.includes('def ') && line.includes('    ')) {
                            result += `  â†³ åµŒå¥—å‡½æ•°å®šä¹‰ (ç¬¬${i + 1}è¡Œ)\n`;
                        }
                    }
                }
                
                // é—®é¢˜æŠ¥å‘Š
                if (issues.length > 0) {
                    result += "\nâš ï¸ å‘ç°çš„é—®é¢˜:\n";
                    result += "â”€".repeat(40) + "\n";
                    issues.forEach(issue => {
                        result += `â€¢ ${issue}\n`;
                    });
                } else {
                    result += "\nâœ… æœªå‘ç°æ˜æ˜¾çš„ç»“æ„é—®é¢˜\n";
                }
                
                // é‡æ„å»ºè®®
                result += "\nğŸ’¡ é‡æ„å»ºè®®:\n";
                result += "â”€".repeat(40) + "\n";
                
                if (complexityScore > 10) {
                    result += "â€¢ è€ƒè™‘æ‹†åˆ†å¤æ‚å‡½æ•°\n";
                    result += "â€¢ æå–é‡å¤ä»£ç ä¸ºç‹¬ç«‹å‡½æ•°\n";
                }
                
                if (functionCount > 5) {
                    result += "â€¢ è€ƒè™‘å°†ç›¸å…³å‡½æ•°ç»„ç»‡åˆ°ç±»ä¸­\n";
                }
                
                // æ£€æŸ¥ç±»å‹æ³¨è§£
                if (!code.includes('->') && !code.includes(':')) {
                    result += "â€¢ å»ºè®®æ·»åŠ ç±»å‹æ³¨è§£\n";
                }
                
                // æ£€æŸ¥æ–‡æ¡£å­—ç¬¦ä¸²
                if (!code.includes('"""') && !code.includes("'''")) {
                    result += "â€¢ å»ºè®®æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²\n";
                }
                
            } catch (error) {
                result += `âŒ åˆ†æé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // å¤æ‚åº¦æ£€æŸ¥å™¨
        function checkComplexity() {
            const code = document.getElementById('complexity-code').value;
            const output = document.getElementById('complexity-output');
            
            let result = "âš™ï¸ ä»£ç å¤æ‚åº¦åˆ†ææŠ¥å‘Š\n\n";
            
            try {
                const lines = code.split('\n');
                let metrics = {
                    cyclomatic: 1,
                    cognitive: 0,
                    nesting: 0,
                    maxNesting: 0,
                    conditions: 0,
                    loops: 0,
                    issues: []
                };
                
                let currentNesting = 0;
                let functionName = null;
                let functionStart = null;
                
                result += "ğŸ“Š å¤æ‚åº¦æŒ‡æ ‡:\n";
                result += "â”€".repeat(40) + "\n";
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    // æ£€æµ‹å‡½æ•°å¼€å§‹
                    if (trimmed.startsWith('def ')) {
                        functionName = trimmed.split('def ')[1].split('(')[0];
                        functionStart = i + 1;
                        currentNesting = 0;
                        metrics.cyclomatic = 1;
                        metrics.cognitive = 0;
                    }
                    
                    // æ£€æŸ¥ç¼©è¿›çº§åˆ«
                    const indent = (line.length - line.trimStart().length) / 4;
                    
                    // æ›´æ–°æœ€å¤§åµŒå¥—æ·±åº¦
                    if (indent > metrics.maxNesting) {
                        metrics.maxNesting = indent;
                    }
                    
                    // åœˆå¤æ‚åº¦è®¡ç®—
                    if (trimmed.includes('if ') || trimmed.includes('elif ') || 
                        trimmed.includes('except ') || trimmed.includes('and ') ||
                        trimmed.includes('or ')) {
                        metrics.cyclomatic++;
                        metrics.conditions++;
                        
                        // è®¤çŸ¥å¤æ‚åº¦å¢åŠ 
                        metrics.cognitive += 1 + currentNesting;
                    }
                    
                    if (trimmed.includes('for ') || trimmed.includes('while ')) {
                        metrics.cyclomatic++;
                        metrics.loops++;
                        metrics.cognitive += 2 + currentNesting;
                    }
                    
                    if (trimmed.includes('try:')) {
                        metrics.cognitive += 1;
                    }
                    
                    // æ›´æ–°åµŒå¥—æ·±åº¦
                    if (trimmed && !trimmed.includes('def ')) {
                        currentNesting = Math.floor(indent / 2);
                    }
                }
                
                result += `åœˆå¤æ‚åº¦: ${metrics.cyclomatic}\n`;
                result += `è®¤çŸ¥å¤æ‚åº¦: ${metrics.cognitive}\n`;
                result += `æœ€å¤§åµŒå¥—æ·±åº¦: ${metrics.maxNesting}\n`;
                result += `æ¡ä»¶è¯­å¥æ•°: ${metrics.conditions}\n`;
                result += `å¾ªç¯è¯­å¥æ•°: ${metrics.loops}\n\n`;
                
                // å¤æ‚åº¦è¯„çº§
                result += "ğŸ“ˆ å¤æ‚åº¦è¯„çº§:\n";
                result += "â”€".repeat(40) + "\n";
                
                if (metrics.cyclomatic <= 10) {
                    result += "åœˆå¤æ‚åº¦: âœ… è‰¯å¥½\n";
                } else if (metrics.cyclomatic <= 20) {
                    result += "åœˆå¤æ‚åº¦: âš ï¸ ä¸­ç­‰\n";
                } else {
                    result += "åœˆå¤æ‚åº¦: âŒ è¿‡é«˜\n";
                }
                
                if (metrics.cognitive <= 15) {
                    result += "è®¤çŸ¥å¤æ‚åº¦: âœ… è‰¯å¥½\n";
                } else if (metrics.cognitive <= 30) {
                    result += "è®¤çŸ¥å¤æ‚åº¦: âš ï¸ ä¸­ç­‰\n";
                } else {
                    result += "è®¤çŸ¥å¤æ‚åº¦: âŒ è¿‡é«˜\n";
                }
                
                if (metrics.maxNesting <= 3) {
                    result += "åµŒå¥—æ·±åº¦: âœ… è‰¯å¥½\n";
                } else if (metrics.maxNesting <= 5) {
                    result += "åµŒå¥—æ·±åº¦: âš ï¸ ä¸­ç­‰\n";
                } else {
                    result += "åµŒå¥—æ·±åº¦: âŒ è¿‡é«˜\n";
                }
                
                // é‡æ„å»ºè®®
                result += "\nğŸ’¡ é‡æ„å»ºè®®:\n";
                result += "â”€".repeat(40) + "\n";
                
                if (metrics.cyclomatic > 10) {
                    result += "â€¢ æ‹†åˆ†å¤æ‚æ¡ä»¶ä¸ºç‹¬ç«‹å‡½æ•°\n";
                    result += "â€¢ ä½¿ç”¨å«è¯­å¥å‡å°‘åµŒå¥—\n";
                }
                
                if (metrics.cognitive > 20) {
                    result += "â€¢ æå–å¤æ‚é€»è¾‘ä¸ºç‹¬ç«‹æ–¹æ³•\n";
                    result += "â€¢ ä½¿ç”¨ç­–ç•¥æ¨¡å¼å¤„ç†å¤šæ¡ä»¶åˆ†æ”¯\n";
                }
                
                if (metrics.maxNesting > 4) {
                    result += "â€¢ å‡å°‘åµŒå¥—å±‚çº§ï¼Œä½¿ç”¨æå‰è¿”å›\n";
                    result += "â€¢ è€ƒè™‘ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼æ›¿ä»£åµŒå¥—å¾ªç¯\n";
                }
                
                if (metrics.conditions > 5) {
                    result += "â€¢ ä½¿ç”¨å¤šæ€æˆ–å­—å…¸æ˜ å°„æ›¿ä»£å¤šä¸ªifè¯­å¥\n";
                }
                
                // æ£€æµ‹å…·ä½“é—®é¢˜
                const nestedPatterns = [
                    /for.*in.*for.*in/,
                    /if.*if.*if/,
                    /try.*except.*try.*except/
                ];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    nestedPatterns.forEach(pattern => {
                        if (pattern.test(line)) {
                            result += `\nâš ï¸ ç¬¬${i + 1}è¡Œ: æ£€æµ‹åˆ°æ·±åº¦åµŒå¥—æ¨¡å¼\n`;
                        }
                    });
                    
                    // æ£€æŸ¥è¶…é•¿æ¡ä»¶
                    if (line.includes('if') && line.length > 80) {
                        result += `\nâš ï¸ ç¬¬${i + 1}è¡Œ: æ¡ä»¶è¯­å¥è¿‡é•¿ï¼Œå»ºè®®æ‹†åˆ†\n`;
                    }
                }
                
            } catch (error) {
                result += `âŒ åˆ†æé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // ç±»å‹æ£€æŸ¥æ¨¡æ‹Ÿå™¨
        function checkTypes() {
            const code = document.getElementById('type-code').value;
            const output = document.getElementById('type-output');
            
            let result = "ğŸ”¬ ç±»å‹æ£€æŸ¥æŠ¥å‘Š\n\n";
            
            try {
                const lines = code.split('\n');
                let typeIssues = [];
                let typeAnnotations = [];
                let returnTypeMismatches = [];
                
                result += "ğŸ“Š ç±»å‹åˆ†æ:\n";
                result += "â”€".repeat(40) + "\n";
                
                let currentFunction = null;
                let expectedReturnType = null;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    // æ£€æµ‹å‡½æ•°å®šä¹‰å’Œè¿”å›ç±»å‹
                    if (trimmed.startsWith('def ')) {
                        const funcMatch = trimmed.match(/def (\w+)\s*\(.*\)\s*->\s*([^:]+)/);
                        if (funcMatch) {
                            currentFunction = funcMatch[1];
                            expectedReturnType = funcMatch[2].trim();
                        }
                    }
                    
                    // æ£€æŸ¥ç±»å‹æ³¨è§£
                    if (trimmed.includes(':') && trimmed.includes('->')) {
                        const annotationMatch = trimmed.match(/(\w+)\s*:\s*([^=,)]+)/g);
                        if (annotationMatch) {
                            annotationMatch.forEach(anno => {
                                typeAnnotations.push(`ç¬¬${i + 1}è¡Œ: ${anno.trim()}`);
                            });
                        }
                    }
                    
                    // æ£€æŸ¥ç±»å‹é”™è¯¯
                    
                    // å­—ç¬¦ä¸²å’Œæ•°å­—æ¯”è¾ƒ
                    if (line.includes('>') || line.includes('<') || line.includes('==')) {
                        const parts = line.split(/[><=!]=?/);
                        if (parts.length >= 2) {
                            const left = parts[0].trim();
                            const right = parts[1].trim();
                            
                            if ((left.includes('"') || left.includes("'")) && 
                                /^\d+$/.test(right)) {
                                typeIssues.push(`ç¬¬${i + 1}è¡Œ: å­—ç¬¦ä¸²ä¸æ•°å­—æ¯”è¾ƒ`);
                            }
                        }
                    }
                    
                    // ç±»å‹è½¬æ¢é—®é¢˜
                    if (line.includes('int(') && line.includes('isdigit()')) {
                        // æ­£ç¡®çš„åšæ³•
                    } else if (line.includes('int(') && (line.includes('"') || line.includes("'"))) {
                        typeIssues.push(`ç¬¬${i + 1}è¡Œ: å¯èƒ½éœ€è¦å…ˆæ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºæ•°å­—`);
                    }
                    
                    // è¿”å›ç±»å‹æ£€æŸ¥
                    if (line.trim().startsWith('return')) {
                        const returnValue = line.trim().substring(6).trim();
                        
                        if (expectedReturnType) {
                            // ç®€å•ç±»å‹æ£€æŸ¥
                            if (expectedReturnType.includes('Dict') && 
                                (returnValue === '{}' || returnValue === 'None')) {
                                returnTypeMismatches.push(`ç¬¬${i + 1}è¡Œ: åº”è¿”å›${expectedReturnType}ï¼Œä½†è¿”å›äº†ç©ºå€¼`);
                            }
                            
                            if (expectedReturnType.includes('Dict') && 
                                returnValue.startsWith('str(')) {
                                returnTypeMismatches.push(`ç¬¬${i + 1}è¡Œ: åº”è¿”å›${expectedReturnType}ï¼Œä½†è¿”å›äº†å­—ç¬¦ä¸²`);
                            }
                        }
                    }
                    
                    // æ£€æŸ¥è¿‡äºå®½æ³›çš„ç±»å‹
                    if (trimmed.includes('Any') || trimmed.includes('object') || 
                        trimmed.includes('Union[Any') || trimmed.includes('Optional[Any')) {
                        typeIssues.push(`ç¬¬${i + 1}è¡Œ: ç±»å‹æ³¨è§£è¿‡äºå®½æ³›ï¼Œåº”ä½¿ç”¨å…·ä½“ç±»å‹`);
                    }
                }
                
                // æŠ¥å‘Šç±»å‹æ³¨è§£
                if (typeAnnotations.length > 0) {
                    result += "âœ… ç±»å‹æ³¨è§£:\n";
                    typeAnnotations.forEach(anno => {
                        result += `  ${anno}\n`;
                    });
                }
                
                // æŠ¥å‘Šç±»å‹é—®é¢˜
                if (typeIssues.length > 0) {
                    result += "\nâš ï¸ ç±»å‹é—®é¢˜:\n";
                    typeIssues.forEach(issue => {
                        result += `  â€¢ ${issue}\n`;
                    });
                }
                
                // æŠ¥å‘Šè¿”å›ç±»å‹ä¸åŒ¹é…
                if (returnTypeMismatches.length > 0) {
                    result += "\nâš ï¸ è¿”å›ç±»å‹ä¸åŒ¹é…:\n";
                    returnTypeMismatches.forEach(issue => {
                        result += `  â€¢ ${issue}\n`;
                    });
                }
                
                if (typeIssues.length === 0 && returnTypeMismatches.length === 0) {
                    result += "\nâœ… æœªå‘ç°æ˜æ˜¾çš„ç±»å‹é—®é¢˜\n";
                }
                
                // ç±»å‹å®‰å…¨å»ºè®®
                result += "\nğŸ’¡ ç±»å‹å®‰å…¨å»ºè®®:\n";
                result += "â”€".repeat(40) + "\n";
                result += "â€¢ ä½¿ç”¨mypyè¿›è¡Œé™æ€ç±»å‹æ£€æŸ¥\n";
                result += "â€¢ é¿å…ä½¿ç”¨Anyç±»å‹ï¼Œå°½é‡å…·ä½“åŒ–\n";
                result += "â€¢ ä½¿ç”¨TypedDictæ›¿ä»£Dict[str, Any]\n";
                result += "â€¢ ä¸ºæ³›å‹å®¹å™¨æŒ‡å®šå…·ä½“ç±»å‹å‚æ•°\n";
                result += "â€¢ ä½¿ç”¨NewTypeåˆ›å»ºå…·æœ‰è¯­ä¹‰çš„ç±»å‹åˆ«å\n";
                
            } catch (error) {
                result += `âŒ åˆ†æé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // å®‰å…¨æ¼æ´æ‰«æå™¨
        function scanSecurity() {
            const code = document.getElementById('security-code').value;
            const output = document.getElementById('security-output');
            
            let result = "ğŸ›¡ï¸ å®‰å…¨æ¼æ´æ‰«ææŠ¥å‘Š\n\n";
            
            try {
                const lines = code.split('\n');
                let vulnerabilities = [];
                
                // æ¼æ´æ¨¡å¼æ£€æµ‹
                const vulnerabilityPatterns = [
                    { 
                        pattern: /f"SELECT.*{\w+}/, 
                        name: "SQLæ³¨å…¥", 
                        severity: "é«˜å±",
                        description: "ä½¿ç”¨f-stringæ‹¼æ¥SQLæŸ¥è¯¢"
                    },
                    { 
                        pattern: /%.*%s.*%/, 
                        name: "SQLæ³¨å…¥", 
                        severity: "é«˜å±",
                        description: "ä½¿ç”¨%æ ¼å¼åŒ–æ‹¼æ¥SQLæŸ¥è¯¢"
                    },
                    { 
                        pattern: /os\.system\(.*\)/, 
                        name: "å‘½ä»¤æ³¨å…¥", 
                        severity: "é«˜å±",
                        description: "ç›´æ¥æ‰§è¡Œç³»ç»Ÿå‘½ä»¤"
                    },
                    { 
                        pattern: /subprocess\.run.*shell=True/, 
                        name: "å‘½ä»¤æ³¨å…¥", 
                        severity: "é«˜å±",
                        description: "ä½¿ç”¨shell=Trueæ‰§è¡Œå‘½ä»¤"
                    },
                    { 
                        pattern: /f".*{.*}.*<\/?[a-z][\s\S]*>/i, 
                        name: "XSSæ¼æ´", 
                        severity: "é«˜å±",
                        description: "æœªè½¬ä¹‰çš„HTMLæ¨¡æ¿"
                    },
                    { 
                        pattern: /open\(.*f"{.*}"\)/, 
                        name: "è·¯å¾„éå†", 
                        severity: "ä¸­å±",
                        description: "æœªéªŒè¯çš„æ–‡ä»¶è·¯å¾„"
                    },
                    { 
                        pattern: /pickle\.loads/, 
                        name: "ååºåˆ—åŒ–æ¼æ´", 
                        severity: "é«˜å±",
                        description: "ä¸å®‰å…¨çš„pickleååºåˆ—åŒ–"
                    },
                    { 
                        pattern: /random\.randint/, 
                        name: "å¼±éšæœºæ•°", 
                        severity: "ä¸­å±",
                        description: "å¯†ç å­¦ä¸Šä¸å®‰å…¨çš„éšæœºæ•°"
                    },
                    { 
                        pattern: /=\s*["'].{10,}["']/, 
                        name: "ç¡¬ç¼–ç å‡­è¯", 
                        severity: "é«˜å±",
                        description: "ä»£ç ä¸­ç¡¬ç¼–ç çš„æ•æ„Ÿä¿¡æ¯"
                    },
                    { 
                        pattern: /debug.*=.*True/, 
                        name: "è°ƒè¯•ä¿¡æ¯æ³„éœ²", 
                        severity: "ä½å±",
                        description: "ç”Ÿäº§ç¯å¢ƒå¯ç”¨äº†è°ƒè¯•æ¨¡å¼"
                    }
                ];
                
                result += "ğŸ” æ¼æ´æ‰«æç»“æœ:\n";
                result += "â”€".repeat(40) + "\n";
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    vulnerabilityPatterns.forEach(pattern => {
                        if (pattern.pattern.test(line)) {
                            vulnerabilities.push({
                                line: i + 1,
                                name: pattern.name,
                                severity: pattern.severity,
                                description: pattern.description,
                                code: trimmed.substring(0, 100)
                            });
                        }
                    });
                }
                
                if (vulnerabilities.length > 0) {
                    // æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
                    const high = vulnerabilities.filter(v => v.severity === "é«˜å±");
                    const medium = vulnerabilities.filter(v => v.severity === "ä¸­å±");
                    const low = vulnerabilities.filter(v => v.severity === "ä½å±");
                    
                    if (high.length > 0) {
                        result += "ğŸ”´ é«˜å±æ¼æ´:\n";
                        high.forEach(vuln => {
                            result += `  ç¬¬${vuln.line}è¡Œ: ${vuln.name} - ${vuln.description}\n`;
                            result += `     ä»£ç : ${vuln.code}\n`;
                        });
                    }
                    
                    if (medium.length > 0) {
                        result += "\nğŸŸ¡ ä¸­å±æ¼æ´:\n";
                        medium.forEach(vuln => {
                            result += `  ç¬¬${vuln.line}è¡Œ: ${vuln.name} - ${vuln.description}\n`;
                        });
                    }
                    
                    if (low.length > 0) {
                        result += "\nğŸŸ¢ ä½å±æ¼æ´:\n";
                        low.forEach(vuln => {
                            result += `  ç¬¬${vuln.line}è¡Œ: ${vuln.name} - ${vuln.description}\n`;
                        });
                    }
                } else {
                    result += "âœ… æœªå‘ç°æ˜æ˜¾çš„å®‰å…¨æ¼æ´\n";
                }
                
                // ä¿®å¤å»ºè®®
                result += "\nğŸ”§ ä¿®å¤å»ºè®®:\n";
                result += "â”€".repeat(40) + "\n";
                result += "SQLæ³¨å…¥:\n";
                result += "  â€¢ ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æˆ–ORM\n";
                result += "  â€¢ éªŒè¯å’Œæ¸…ç†æ‰€æœ‰ç”¨æˆ·è¾“å…¥\n\n";
                
                result += "å‘½ä»¤æ³¨å…¥:\n";
                result += "  â€¢ é¿å…ä½¿ç”¨shell=True\n";
                result += "  â€¢ ä½¿ç”¨shlex.quoteæ¸…ç†å‚æ•°\n";
                result += "  â€¢ é™åˆ¶å¯æ‰§è¡Œçš„å‘½ä»¤åˆ—è¡¨\n\n";
                
                result += "XSSæ¼æ´:\n";
                result += "  â€¢ å¯¹è¾“å‡ºè¿›è¡ŒHTMLè½¬ä¹‰\n";
                result += "  â€¢ ä½¿ç”¨å®‰å…¨çš„æ¨¡æ¿å¼•æ“\n";
                result += "  â€¢ è®¾ç½®Content-Security-Policy\n\n";
                
                result += "å…¶ä»–å®‰å…¨å»ºè®®:\n";
                result += "  â€¢ ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯\n";
                result += "  â€¢ ç¦ç”¨ç”Ÿäº§ç¯å¢ƒçš„è°ƒè¯•åŠŸèƒ½\n";
                result += "  â€¢ å®šæœŸæ›´æ–°ä¾èµ–åº“ç‰ˆæœ¬\n";
                result += "  â€¢ å®æ–½è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç \n";
                
            } catch (error) {
                result += `âŒ æ‰«æé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // ç±»ç”Ÿæˆå™¨
        function generateClass() {
            const className = document.getElementById('class-name').value;
            const propertiesText = document.getElementById('class-properties').value;
            const methodsText = document.getElementById('class-methods').value;
            const features = document.getElementById('class-features').value;
            const output = document.getElementById('class-output');
            
            let result = `ğŸ—ï¸ ç”Ÿæˆçš„ç±»: ${className}\n\n`;
            
            try {
                // è§£æå±æ€§
                const properties = [];
                const propertiesLines = propertiesText.split('\n').filter(line => line.trim());
                propertiesLines.forEach(line => {
                    const parts = line.split(':');
                    if (parts.length >= 2) {
                        const name = parts[0].trim();
                        const typeAndDefault = parts[1].trim();
                        const defaultValue = typeAndDefault.includes('=') ? 
                            typeAndDefault.split('=')[1].trim() : null;
                        const type = typeAndDefault.split('=')[0].trim();
                        
                        properties.push({
                            name,
                            type,
                            defaultValue
                        });
                    }
                });
                
                // è§£ææ–¹æ³•
                const methods = [];
                const methodsLines = methodsText.split('\n').filter(line => line.trim());
                methodsLines.forEach(line => {
                    const parts = line.split(':');
                    if (parts.length >= 3) {
                        methods.push({
                            name: parts[0].trim(),
                            returnType: parts[1].trim(),
                            description: parts[2].trim()
                        });
                    }
                });
                
                // ç”Ÿæˆä»£ç 
                let code = '';
                
                // å¯¼å…¥è¯­å¥
                const typesNeeded = new Set();
                properties.forEach(prop => {
                    if (prop.type.includes('Optional') || prop.type.includes('List') || 
                        prop.type.includes('Dict') || prop.type.includes('Union')) {
                        typesNeeded.add('typing');
                    }
                });
                
                if (typesNeeded.has('typing')) {
                    code += "from typing import Optional, List, Dict, Union, Any\n\n";
                }
                
                // ç±»å®šä¹‰
                if (features === 'dataclass') {
                    code += "from dataclasses import dataclass, field\n\n";
                    code += "@dataclass\n";
                } else if (features === 'pydantic') {
                    code += "from pydantic import BaseModel, Field\n\n";
                }
                
                code += `class ${className}`;
                
                if (features === 'pydantic') {
                    code += "(BaseModel):\n";
                } else {
                    code += ":\n";
                }
                
                // æ–‡æ¡£å­—ç¬¦ä¸²
                code += `    """${className}ç±»"""
    
`;
                
                // åˆå§‹åŒ–æ–¹æ³•
                if (features !== 'dataclass' && features !== 'pydantic') {
                    code += "    def __init__(self"
                    
                    // æ„é€ å‡½æ•°å‚æ•°
                    properties.forEach(prop => {
                        code += `, ${prop.name}: ${prop.type}`;
                        if (prop.defaultValue) {
                            code += ` = ${prop.defaultValue}`;
                        }
                    });
                    
                    code += "):\n";
                    code += `        """åˆå§‹åŒ–${className}"""
        
`;
                    
                    // å±æ€§èµ‹å€¼
                    properties.forEach(prop => {
                        code += `        self.${prop.name} = ${prop.name}\n`;
                    });
                } else if (features === 'dataclass') {
                    // æ•°æ®ç±»å±æ€§
                    properties.forEach(prop => {
                        code += `    ${prop.name}: ${prop.type}`;
                        if (prop.defaultValue) {
                            code += ` = ${prop.defaultValue}`;
                        }
                        code += "\n";
                    });
                    code += "\n";
                } else if (features === 'pydantic') {
                    // Pydanticæ¨¡å‹å­—æ®µ
                    properties.forEach(prop => {
                        code += `    ${prop.name}: ${prop.type}`;
                        if (prop.defaultValue) {
                            code += ` = ${prop.defaultValue}`;
                        }
                        code += "\n";
                    });
                    code += "\n";
                }
                
                // ç”Ÿæˆæ–¹æ³•
                methods.forEach(method => {
                    code += `    def ${method.name}(self) -> ${method.returnType}:\n`;
                    code += `        """${method.description}"""
        # TODO: å®ç°æ–¹æ³•é€»è¾‘
        raise NotImplementedError("æ–¹æ³•æœªå®ç°")
    
`;
                });
                
                // é­”æœ¯æ–¹æ³•ï¼ˆå®Œæ•´ç±»ï¼‰
                if (features === 'full') {
                    code += `    def __str__(self) -> str:\n`;
                    code += `        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        return f"{className}("
`;
                    properties.forEach((prop, index) => {
                        code += `            {self.${prop.name}}`;
                        if (index < properties.length - 1) {
                            code += ` + ", " + `;
                        }
                    });
                    code += `        )\n\n`;
                    
                    code += `    def __repr__(self) -> str:\n`;
                    code += `        """å®˜æ–¹å­—ç¬¦ä¸²è¡¨ç¤º"""
        return f"{className}("
`;
                    properties.forEach((prop, index) => {
                        code += `            ${prop.name}={{self.${prop.name}!r}}`;
                        if (index < properties.length - 1) {
                            code += ` + ", " + `;
                        }
                    });
                    code += `        )\n\n`;
                    
                    code += `    def __eq__(self, other: object) -> bool:\n`;
                    code += `        """ç›¸ç­‰æ€§æ¯”è¾ƒ"""
        if not isinstance(other, ${className}):
            return NotImplemented
        return (
`;
                    properties.forEach((prop, index) => {
                        code += `            self.${prop.name} == other.${prop.name}`;
                        if (index < properties.length - 1) {
                            code += " and\n";
                        }
                    });
                    code += `\n        )\n`;
                }
                
                result += code;
                result += "\nğŸ“‹ ç”Ÿæˆç»Ÿè®¡:\n";
                result += `å±æ€§æ•°: ${properties.length}\n`;
                result += `æ–¹æ³•æ•°: ${methods.length}\n`;
                result += `ç‰¹æ€§: ${features}\n`;
                
            } catch (error) {
                result += `âŒ ç”Ÿæˆé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // APIä»£ç ç”Ÿæˆå™¨
        function generateAPI() {
            const framework = document.getElementById('api-framework').value;
            const endpointsText = document.getElementById('api-endpoints').value;
            const modelsText = document.getElementById('api-models').value;
            const output = document.getElementById('api-output');
            
            let result = `ğŸŒ ç”Ÿæˆçš„${framework === 'fastapi' ? 'FastAPI' : 'Flask'}ä»£ç \n\n`;
            
            try {
                // è§£æç«¯ç‚¹é…ç½®
                let endpoints;
                try {
                    endpoints = JSON.parse(endpointsText);
                } catch (e) {
                    result += `âŒ ç«¯ç‚¹é…ç½®JSONè§£æé”™è¯¯: ${e.message}\n`;
                    output.textContent = result;
                    return;
                }
                
                // è§£ææ¨¡å‹
                const models = [];
                const modelsLines = modelsText.split('\n').filter(line => line.trim());
                modelsLines.forEach(line => {
                    const parts = line.split(':');
                    if (parts.length >= 2) {
                        const name = parts[0].trim();
                        const fields = parts[1].trim();
                        
                        const fieldList = fields.split(',').map(field => {
                            const fieldParts = field.split(':');
                            return {
                                name: fieldParts[0].trim(),
                                type: fieldParts[1] ? fieldParts[1].trim() : 'Any'
                            };
                        });
                        
                        models.push({ name, fields: fieldList });
                    }
                });
                
                // ç”Ÿæˆå¯¼å…¥è¯­å¥
                let code = '';
                
                if (framework === 'fastapi') {
                    code += "from fastapi import FastAPI, HTTPException, Depends, status\n";
                    code += "from pydantic import BaseModel\n";
                    code += "from typing import Optional, List, Dict, Any\n";
                    code += "from datetime import datetime\n\n";
                    code += "app = FastAPI(title='APIæœåŠ¡', version='1.0.0')\n\n";
                } else {
                    code += "from flask import Flask, request, jsonify\n";
                    code += "from typing import Optional, List, Dict, Any\n";
                    code += "from datetime import datetime\n\n";
                    code += "app = Flask(__name__)\n\n";
                }
                
                // ç”Ÿæˆæ•°æ®æ¨¡å‹
                if (models.length > 0) {
                    code += "# æ•°æ®æ¨¡å‹\n";
                    models.forEach(model => {
                        if (framework === 'fastapi') {
                            code += `class ${model.name}(BaseModel):\n`;
                        } else {
                            code += `class ${model.name}:\n`;
                            code += "    def __init__(self";
                            model.fields.forEach(field => {
                                code += `, ${field.name}: ${field.type}`;
                            });
                            code += "):\n";
                            
                            model.fields.forEach(field => {
                                code += `        self.${field.name} = ${field.name}\n`;
                            });
                            code += "    \n";
                            code += "    def to_dict(self):\n";
                            code += "        return {\n";
                            model.fields.forEach(field => {
                                code += `            '${field.name}': self.${field.name},\n`;
                            });
                            code += "        }\n\n";
                        }
                        
                        if (framework === 'fastapi') {
                            model.fields.forEach(field => {
                                code += `    ${field.name}: ${field.type}\n`;
                            });
                            code += "\n";
                        }
                    });
                }
                
                // ç”Ÿæˆç«¯ç‚¹
                code += "# APIç«¯ç‚¹\n";
                endpoints.forEach(endpoint => {
                    endpoint.methods.forEach(method => {
                        const methodLower = method.toLowerCase();
                        
                        // ç”Ÿæˆè·¯ç”±è£…é¥°å™¨
                        if (framework === 'fastapi') {
                            code += `@app.${methodLower}("${endpoint.path}")\n`;
                        } else {
                            code += `@app.route("${endpoint.path}", methods=['${method}'])\n`;
                        }
                        
                        // ç”Ÿæˆå‡½æ•°ç­¾å
                        const funcName = endpoint.path.replace(/[\/{}]/g, '_').replace(/^_/, '') + 
                                       '_' + methodLower;
                        code += `async def ${funcName}(`;
                        
                        // æ·»åŠ å‚æ•°
                        const params = [];
                        if (endpoint.params) {
                            endpoint.params.forEach(param => {
                                let paramStr = param.name + ': ' + param.type;
                                if (!param.required) {
                                    paramStr += ' = None';
                                }
                                params.push(paramStr);
                            });
                        }
                        code += params.join(', ');
                        code += "):\n";
                        
                        // ç”Ÿæˆæ–‡æ¡£å­—ç¬¦ä¸²
                        code += `    """${endpoint.summary || 'APIç«¯ç‚¹'}\n`;
                        if (endpoint.params) {
                            code += "\n    å‚æ•°:\n";
                            endpoint.params.forEach(param => {
                                code += `        ${param.name}: ${param.location}å‚æ•°\n`;
                            });
                        }
                        if (endpoint.responses) {
                            code += "\n    å“åº”:\n";
                            Object.entries(endpoint.responses).forEach(([code, resp]) => {
                                code += `        ${code}: ${resp.description}\n`;
                            });
                        }
                        code += `    """\n`;
                        
                        // ç”Ÿæˆå‡½æ•°ä½“
                        code += "    # TODO: å®ç°ä¸šåŠ¡é€»è¾‘\n";
                        
                        if (method === 'GET') {
                            code += "    # ç¤ºä¾‹ï¼šè¿”å›å‡æ•°æ®\n";
                            code += "    return [\n";
                            code += "        {\"id\": 1, \"name\": \"ç¤ºä¾‹ç”¨æˆ·\"},\n";
                            code += "        {\"id\": 2, \"name\": \"æµ‹è¯•ç”¨æˆ·\"}\n";
                            code += "    ]\n\n";
                        } else if (method === 'POST') {
                            code += "    # ç¤ºä¾‹ï¼šåˆ›å»ºæ–°èµ„æº\n";
                            code += "    new_id = 1  # åº”è¯¥æ˜¯ä»æ•°æ®åº“ç”Ÿæˆçš„ID\n";
                            code += "    return {\n";
                            code += "        \"id\": new_id,\n";
                            code += "        \"message\": \"åˆ›å»ºæˆåŠŸ\",\n";
                            code += "        \"data\": {\"id\": new_id}  # è¿”å›åˆ›å»ºçš„æ•°æ®\n";
                            code += "    }\n\n";
                        } else {
                            code += "    return {\"message\": \"åŠŸèƒ½å¾…å®ç°\"}\n\n";
                        }
                    });
                });
                
                // ç”Ÿæˆä¸»å‡½æ•°
                code += "\n# ä¸»å‡½æ•°\n";
                code += "if __name__ == '__main__':\n";
                if (framework === 'fastapi') {
                    code += "    import uvicorn\n";
                    code += "    uvicorn.run(app, host='0.0.0.0', port=8000)\n";
                } else {
                    code += "    app.run(debug=True, host='0.0.0.0', port=5000)\n";
                }
                
                result += code;
                result += "\nğŸ“Š ç”Ÿæˆç»Ÿè®¡:\n";
                result += `æ¡†æ¶: ${framework === 'fastapi' ? 'FastAPI' : 'Flask'}\n`;
                result += `ç«¯ç‚¹æ•°é‡: ${endpoints.length}\n`;
                result += `æ¨¡å‹æ•°é‡: ${models.length}\n`;
                
            } catch (error) {
                result += `âŒ ç”Ÿæˆé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

        // ä¾èµ–åˆ†æå™¨
        function analyzeDependencies() {
            const code = document.getElementById('dependency-code').value;
            const output = document.getElementById('dependency-output');
            
            let result = "ğŸ“¦ ä¾èµ–åˆ†ææŠ¥å‘Š\n\n";
            
            try {
                const lines = code.split('\n');
                let imports = {
                    stdlib: new Set(),
                    thirdParty: new Set(),
                    local: new Set(),
                    unused: new Set(),
                    cyclic: new Set(),
                    versionIssues: new Set()
                };
                
                let importStatements = [];
                
                // æ”¶é›†æ‰€æœ‰å¯¼å…¥
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.startsWith('import ') || line.startsWith('from ')) {
                        importStatements.push({ line: i + 1, text: line });
                        
                        // è§£æå¯¼å…¥
                        if (line.startsWith('import ')) {
                            const modules = line.substring(7).split(',');
                            modules.forEach(module => {
                                const moduleName = module.trim().split(' as ')[0].trim();
                                imports.stdlib.add(moduleName);
                            });
                        } else if (line.startsWith('from ')) {
                            const parts = line.split(' ');
                            if (parts.length >= 4) {
                                const moduleName = parts[1].trim();
                                imports.stdlib.add(moduleName);
                            }
                        }
                    }
                }
                
                // æ£€æŸ¥æœªä½¿ç”¨çš„å¯¼å…¥
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦åˆ†æä»£ç ä¸­æ˜¯å¦ä½¿ç”¨äº†å¯¼å…¥çš„æ¨¡å—
                
                // æ£€æŸ¥ç¬¬ä¸‰æ–¹åº“
                const thirdPartyLibs = ['requests', 'numpy', 'pandas', 'sqlalchemy', 
                                       'tensorflow', 'torch', 'django', 'matplotlib', 'seaborn'];
                thirdPartyLibs.forEach(lib => {
                    if (Array.from(imports.stdlib).some(module => module.includes(lib))) {
                        imports.stdlib.delete(lib);
                        imports.thirdParty.add(lib);
                    }
                });
                
                // æ£€æŸ¥æ¨¡ç³Šå¯¼å…¥
                const wildcardImports = importStatements.filter(stmt => 
                    stmt.text.includes('import *'));
                
                // æ£€æŸ¥Python 2é—ç•™æ¨¡å—
                const python2Modules = ['md5', 'urllib2', 'cgi', 'cStringIO'];
                const foundPython2 = importStatements.filter(stmt => 
                    python2Modules.some(module => stmt.text.includes(module)));
                
                result += "ğŸ“Š å¯¼å…¥ç»Ÿè®¡:\n";
                result += "â”€".repeat(40) + "\n";
                result += `æ ‡å‡†åº“: ${imports.stdlib.size} ä¸ª\n`;
                result += `ç¬¬ä¸‰æ–¹åº“: ${imports.thirdParty.size} ä¸ª\n`;
                
                if (imports.stdlib.size > 0) {
                    result += "\nğŸ“š æ ‡å‡†åº“å¯¼å…¥:\n";
                    Array.from(imports.stdlib).forEach(module => {
                        result += `  â€¢ ${module}\n`;
                    });
                }
                
                if (imports.thirdParty.size > 0) {
                    result += "\nğŸŒ ç¬¬ä¸‰æ–¹åº“å¯¼å…¥:\n";
                    Array.from(imports.thirdParty).forEach(lib => {
                        result += `  â€¢ ${lib}\n`;
                    });
                }
                
                // é—®é¢˜æŠ¥å‘Š
                let issues = [];
                
                if (wildcardImports.length > 0) {
                    issues.push("âš ï¸ å‘ç°æ¨¡ç³Šå¯¼å…¥ (from ... import *)ï¼Œåº”é¿å…ä½¿ç”¨");
                }
                
                if (foundPython2.length > 0) {
                    issues.push("âš ï¸ å‘ç°Python 2é—ç•™æ¨¡å—å¯¼å…¥ï¼Œéœ€è¦æ›´æ–°åˆ°Python 3");
                }
                
                // æ£€æŸ¥é‡å¤å¯¼å…¥
                const importCounts = {};
                importStatements.forEach(stmt => {
                    const moduleMatch = stmt.text.match(/(?:import|from) (\w+)/);
                    if (moduleMatch) {
                        const module = moduleMatch[1];
                        importCounts[module] = (importCounts[module] || 0) + 1;
                    }
                });
                
                const duplicates = Object.entries(importCounts)
                    .filter(([_, count]) => count > 1)
                    .map(([module, count]) => `${module} (${count}æ¬¡)`);
                
                if (duplicates.length > 0) {
                    issues.push(`âš ï¸ é‡å¤å¯¼å…¥: ${duplicates.join(', ')}`);
                }
                
                // æ£€æŸ¥æ¡ä»¶å¯¼å…¥
                const conditionalImports = importStatements.filter(stmt => {
                    const prevLine = lines[stmt.line - 2] ? lines[stmt.line - 2].trim() : '';
                    return prevLine.includes('if ') || prevLine.includes('try:');
                });
                
                if (conditionalImports.length > 0) {
                    issues.push("âš ï¸ å‘ç°æ¡ä»¶å¯¼å…¥ï¼Œå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯");
                }
                
                // è¾“å‡ºé—®é¢˜
                if (issues.length > 0) {
                    result += "\nğŸš¨ å‘ç°çš„é—®é¢˜:\n";
                    result += "â”€".repeat(40) + "\n";
                    issues.forEach(issue => {
                        result += `â€¢ ${issue}\n`;
                    });
                } else {
                    result += "\nâœ… å¯¼å…¥ç»“æ„è‰¯å¥½\n";
                }
                
                // ä¼˜åŒ–å»ºè®®
                result += "\nğŸ’¡ ä¼˜åŒ–å»ºè®®:\n";
                result += "â”€".repeat(40) + "\n";
                result += "1. é¿å…ä½¿ç”¨æ¨¡ç³Šå¯¼å…¥ (import *)\n";
                result += "2. å°†å¯¼å…¥æŒ‰æ ‡å‡†åº“ã€ç¬¬ä¸‰æ–¹åº“ã€æœ¬åœ°æ¨¡å—åˆ†ç»„\n";
                result += "3. ä½¿ç”¨ç»å¯¹å¯¼å…¥æ›¿ä»£ç›¸å¯¹å¯¼å…¥\n";
                result += "4. è€ƒè™‘ä½¿ç”¨__init__.pyç»„ç»‡æ¨¡å—\n";
                result += "5. å®šæœŸæ¸…ç†æœªä½¿ç”¨çš„å¯¼å…¥\n";
                
                // ä¾èµ–ç®¡ç†å»ºè®®
                if (imports.thirdParty.size > 0) {
                    result += "\nğŸ“¦ ä¾èµ–ç®¡ç†å»ºè®®:\n";
                    result += "â”€".repeat(40) + "\n";
                    result += "å»ºè®®åˆ›å»ºrequirements.txtæ–‡ä»¶:\n";
                    result += "```\n";
                    Array.from(imports.thirdParty).forEach(lib => {
                        result += `${lib}>=1.0.0\n`;
                    });
                    result += "```\n\n";
                    
                    result += "æˆ–è€…ä½¿ç”¨Pipfile:\n";
                    result += "```\n[packages]\n";
                    Array.from(imports.thirdParty).forEach(lib => {
                        result += `${lib} = \"*\"\n`;
                    });
                    result += "```\n";
                }
                
            } catch (error) {
                result += `âŒ åˆ†æé”™è¯¯: ${error.message}\n`;
            }
            
            output.textContent = result;
        }

// é”™è¯¯æ¨¡æ‹Ÿå™¨
function simulateError() {
    const errorType = document.getElementById('error-type').value;
    const output = document.getElementById('error-output');
    
    let result = `âš ï¸ æ¨¡æ‹ŸPython ${errorType}é”™è¯¯\n\n`;
    
    try {
        const errorExamples = {
            syntax: `# è¯­æ³•é”™è¯¯ç¤ºä¾‹
def broken_function()
    print("ç¼ºå°‘å†’å·")
    
# å¦ä¸€ä¸ªè¯­æ³•é”™è¯¯
if True
    print("ç¼ºå°‘å†’å·")

# ä¸åŒ¹é…çš„æ‹¬å·
result = (1 + 2 * 3

# æ— æ•ˆçš„ç¼©è¿›
def test():
print("ç¼©è¿›é”™è¯¯")`,

            type: `# ç±»å‹é”™è¯¯ç¤ºä¾‹
result = "hello" + 123  # å­—ç¬¦ä¸²å’Œæ•°å­—ä¸èƒ½ç›¸åŠ 

# åˆ—è¡¨å’Œå­—ç¬¦ä¸²æ“ä½œ
items = [1, 2, 3]
items["key"] = "value"  # é”™è¯¯ï¼šåˆ—è¡¨ä¸èƒ½é€šè¿‡å­—ç¬¦ä¸²ç´¢å¼•èµ‹å€¼

# è°ƒç”¨éå‡½æ•°å¯¹è±¡
number = 42
number()  # é”™è¯¯ï¼šæ•´æ•°å¯¹è±¡ä¸å¯è°ƒç”¨

# ä¸å…¼å®¹çš„ç±»å‹æ“ä½œ
value = len(123)  # é”™è¯¯ï¼šæ•´æ•°æ²¡æœ‰é•¿åº¦`,

            import: `# å¯¼å…¥é”™è¯¯ç¤ºä¾‹
import non_existent_module  # æ¨¡å—ä¸å­˜åœ¨

# å¯¼å…¥ä¸å­˜åœ¨çš„å±æ€§
from math import non_existent_function  # å‡½æ•°ä¸å­˜åœ¨

# å¾ªç¯å¯¼å…¥å¯¼è‡´çš„é”™è¯¯
# module_a.py
# import module_b

# module_b.py  
# import module_a

# ç‰ˆæœ¬ä¸å…¼å®¹å¯¼å…¥
import python2_only_module  # Python 3ä¸­ä¸å­˜åœ¨çš„æ¨¡å—`,

            attribute: `# å±æ€§é”™è¯¯ç¤ºä¾‹
class MyClass:
    def __init__(self):
        self.value = 10

obj = MyClass()
print(obj.non_existent_attribute)  # è®¿é—®ä¸å­˜åœ¨çš„å±æ€§

# å†…ç½®ç±»å‹å±æ€§é”™è¯¯
text = "hello"
text.non_existent_method()  # å­—ç¬¦ä¸²æ²¡æœ‰è¿™ä¸ªæ–¹æ³•

# Noneå¯¹è±¡å±æ€§è®¿é—®
result = None
result.some_attribute  # Noneæ²¡æœ‰å±æ€§`,

            key: `# é”®é”™è¯¯ç¤ºä¾‹
data = {"name": "John", "age": 30}
print(data["address"])  # é”®ä¸å­˜åœ¨

# ç©ºå­—å…¸è®¿é—®
empty_dict = {}
empty_dict["key"]  # ç©ºå­—å…¸æ²¡æœ‰é”®

# å¤šå±‚å­—å…¸è®¿é—®
nested = {"a": {"b": {"c": 1}}}
nested["x"]["y"]["z"]  # ä¸­é—´é”®ä¸å­˜åœ¨`,

            index: `# ç´¢å¼•é”™è¯¯ç¤ºä¾‹
items = [1, 2, 3]
print(items[10])  # ç´¢å¼•è¶…å‡ºèŒƒå›´

# ç©ºåˆ—è¡¨ç´¢å¼•
empty_list = []
empty_list[0]  # ç©ºåˆ—è¡¨æ²¡æœ‰ç´¢å¼•0

# å­—ç¬¦ä¸²ç´¢å¼•
text = "hello"
text[10]  # å­—ç¬¦ä¸²ç´¢å¼•è¶…å‡ºèŒƒå›´

# è´Ÿæ•°ç´¢å¼•è¿‡å¤§
items[-10]  # è´Ÿæ•°ç´¢å¼•è¶…å‡ºèŒƒå›´`,

            value: `# å€¼é”™è¯¯ç¤ºä¾‹
int("not_a_number")  # æ— æ³•è½¬æ¢ä¸ºæ•´æ•°

# åˆ—è¡¨ç´¢å¼•å€¼é”™è¯¯
import math
math.sqrt(-1)  # è´Ÿæ•°çš„å¹³æ–¹æ ¹

# ä¸æ”¯æŒçš„æ ¼å¼
datetime.strptime("invalid_date", "%Y-%m-%d")  # æ ¼å¼ä¸åŒ¹é…

# æ— æ•ˆå‚æ•°
list(range(10, 1, 0))  # stepä¸º0`,

            name: `# åç§°é”™è¯¯ç¤ºä¾‹
print(undefined_variable)  # å˜é‡æœªå®šä¹‰

# å‡½æ•°åé”™è¯¯
non_existent_function()  # å‡½æ•°æœªå®šä¹‰

# ç±»åé”™è¯¯
obj = UndefinedClass()  # ç±»æœªå®šä¹‰

# æ‹¼å†™é”™è¯¯
value = 10
print(valu)  # å˜é‡åæ‹¼å†™é”™è¯¯`,

            recursion: `# é€’å½’é”™è¯¯ç¤ºä¾‹
def infinite_recursion():
    infinite_recursion()  # æ— é™é€’å½’

infinite_recursion()

# é€’å½’æ·±åº¦è¿‡å¤§
def deep_recursion(n):
    if n <= 0:
        return 0
    return deep_recursion(n-1)

deep_recursion(10000)  # è¶…å‡ºé€’å½’æ·±åº¦é™åˆ¶`,

            memory: `# å†…å­˜é”™è¯¯ç¤ºä¾‹
# åˆ›å»ºè¶…å¤§å¯¹è±¡
huge_list = [0] * (10**9)  # å¯èƒ½å†…å­˜ä¸è¶³

# å†…å­˜æ³„æ¼æ¨¡æ‹Ÿ
leaking_data = []
while True:
    leaking_data.append("x" * 1000000)  # æŒç»­åˆ†é…å†…å­˜

# å¾ªç¯å¼•ç”¨å¯¼è‡´æ— æ³•åƒåœ¾å›æ”¶
class Node:
    def __init__(self):
        self.ref = None

a = Node()
b = Node()
a.ref = b
b.ref = a  # å¾ªç¯å¼•ç”¨`,

            all: `# å¤šç§å¸¸è§é”™è¯¯ç¤ºä¾‹é›†åˆ
# è¯­æ³•é”™è¯¯
def bad_syntax(

# ç±»å‹é”™è¯¯
result = "text" + 123

# åç§°é”™è¯¯  
print(undefined)

# ç´¢å¼•é”™è¯¯
items = []
items[0]

# é”®é”™è¯¯
data = {}
data["key"]

# å±æ€§é”™è¯¯
None.some_attr

# å€¼é”™è¯¯
int("abc")

# å¯¼å…¥é”™è¯¯
import non_existent`
        };
        
        if (errorExamples[errorType]) {
            result += errorExamples[errorType];
            
            // æ·»åŠ è°ƒè¯•å»ºè®®
            result += "\n\nğŸ”§ è°ƒè¯•å»ºè®®:\n";
            result += "â”€".repeat(40) + "\n";
            
            switch(errorType) {
                case 'syntax':
                    result += "â€¢ æ£€æŸ¥æ‹¬å·ã€å¼•å·æ˜¯å¦åŒ¹é…\n";
                    result += "â€¢ æ£€æŸ¥å†’å·å’Œç¼©è¿›æ˜¯å¦æ­£ç¡®\n";
                    result += "â€¢ ä½¿ç”¨ä»£ç ç¼–è¾‘å™¨çš„è¯­æ³•é«˜äº®åŠŸèƒ½\n";
                    break;
                case 'type':
                    result += "â€¢ æ£€æŸ¥å˜é‡çš„æ•°æ®ç±»å‹\n";
                    result += "â€¢ ä½¿ç”¨ç±»å‹æ³¨è§£å’Œç±»å‹æ£€æŸ¥å·¥å…·\n";
                    result += "â€¢ è¿›è¡Œæ˜¾å¼çš„ç±»å‹è½¬æ¢\n";
                    break;
                case 'import':
                    result += "â€¢ æ£€æŸ¥æ¨¡å—æ˜¯å¦å·²å®‰è£…\n";
                    result += "â€¢ æ£€æŸ¥æ¨¡å—åç§°æ‹¼å†™\n";
                    result += "â€¢ æ£€æŸ¥PYTHONPATHè®¾ç½®\n";
                    break;
                default:
                    result += "â€¢ é˜…è¯»é”™è¯¯ä¿¡æ¯çš„è¯¦ç»†æè¿°\n";
                    result += "â€¢ ä½¿ç”¨try-exceptæ•è·å¼‚å¸¸\n";
                    result += "â€¢ ä½¿ç”¨è°ƒè¯•å™¨é€æ­¥æ‰§è¡Œä»£ç \n";
            }
        } else {
            result += "âŒ æœªçŸ¥é”™è¯¯ç±»å‹";
        }
        
    } catch (error) {
        result += `âŒ æ¨¡æ‹Ÿé”™è¯¯æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}\n`;
    }
    
    output.textContent = result;
}