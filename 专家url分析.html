<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸“å®¶çº§URLåˆ†æç³»ç»Ÿ</title>
    <style>
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            margin: 20px; 
            font-size: 13px;
            background: #f8f9fa;
        }
        h1, h2 { 
            margin: 15px 0 10px 0; 
            color: #2c3e50;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 5px;
        }
        .tool-section { 
            margin: 20px 0; 
            padding: 15px; 
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        input, textarea, select { 
            width: 100%; 
            padding: 8px; 
            border: 1px solid #ced4da; 
            border-radius: 3px; 
            font-family: inherit;
            font-size: 13px;
            margin: 5px 0;
            background: #f8f9fa;
        }
        textarea { 
            height: 100px; 
            resize: vertical;
        }
        button { 
            padding: 8px 15px; 
            background: #3498db; 
            color: white; 
            border: none; 
            border-radius: 3px; 
            cursor: pointer; 
            font-size: 13px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }
        button:hover { background: #2980b9; }
        .result { 
            margin: 10px 0; 
            padding: 12px; 
            border: 1px solid #dee2e6; 
            border-radius: 3px; 
            background: white;
            font-family: inherit;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .status-good { color: #27ae60; }
        .status-warning { color: #f39c12; }
        .status-bad { color: #e74c3c; }
        .inline { display: inline-block; margin-right: 10px; }
        .code { background: #2c3e50; color: #ecf0f1; padding: 3px 6px; border-radius: 3px; }
        .tab { 
            display: inline-block; 
            padding: 8px 15px; 
            cursor: pointer; 
            border: 1px solid #dee2e6;
            border-bottom: none;
            background: #f8f9fa;
            margin-right: -1px;
        }
        .tab.active { 
            background: white; 
            border-bottom: 1px solid white; 
            margin-bottom: -1px;
        }
        .tab-content { 
            display: none; 
            padding: 15px; 
            border: 1px solid #dee2e6; 
            background: white;
        }
        .tab-content.active { display: block; }
        .hex { font-family: monospace; color: #3498db; }
        .param-row { 
            display: grid; 
            grid-template-columns: 1fr 1fr 100px; 
            gap: 10px; 
            margin: 5px 0;
            align-items: center;
        }
    </style>
</head>
<body>
    <h1>ğŸ”— ä¸“å®¶çº§URLåˆ†æç³»ç»Ÿ</h1>
    <h2>å¼€å‘è€…ï¼šRiver</h2>
    
    <div style="margin-bottom: 20px;">
        <input type="text" id="masterUrl" placeholder="è¾“å…¥ä¸»URL (å°†ç”¨äºå¤šä¸ªå·¥å…·)" 
               value="https://user:pass@www.example.com:8080/path/to/page?q=æµ‹è¯•&sort=desc#section" 
               style="font-size: 14px; padding: 10px;">
    </div>

    <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
    <div style="margin-bottom: -1px;">
        <div class="tab active" onclick="switchTab('security')">ğŸ”’ å®‰å…¨åˆ†æ</div>
        <div class="tab" onclick="switchTab('protocol')">ğŸ“¡ åè®®åˆ†æ</div>
        <div class="tab" onclick="switchTab('structure')">ğŸ—ï¸ ç»“æ„åˆ†æ</div>
        <div class="tab" onclick="switchTab('advanced')">âš¡ é«˜çº§å·¥å…·</div>
    </div>

    <!-- å®‰å…¨åˆ†ææ ‡ç­¾é¡µ -->
    <div id="security-tab" class="tab-content active">
        <div class="grid">
            <!-- å·¥å…·1: URLæ³¨å…¥æ£€æµ‹ -->
            <div class="tool-section">
                <h2>ğŸ” URLæ³¨å…¥æ£€æµ‹</h2>
                <textarea id="injectionUrl" placeholder="è¾“å…¥è¦æ£€æµ‹çš„URL">https://example.com/page?redirect=https://evil.com&data=<script>alert(1)</script></textarea>
                <button onclick="detectInjection()">æ£€æµ‹æ³¨å…¥</button>
                <div class="result" id="injectionResult"></div>
            </div>

            <!-- å·¥å…·2: åŒæºç­–ç•¥åˆ†æ -->
            <div class="tool-section">
                <h2>ğŸ›¡ï¸ åŒæºç­–ç•¥åˆ†æ</h2>
                <div style="margin: 10px 0;">
                    <div class="param-row">
                        <input type="text" id="origin1" value="https://example.com" placeholder="æº1">
                        <input type="text" id="origin2" value="https://api.example.com" placeholder="æº2">
                        <button onclick="analyzeCORS()">åˆ†æ</button>
                    </div>
                </div>
                <div class="result" id="corsResult"></div>
            </div>

            <!-- å·¥å…·3: SSRFé£é™©æ£€æµ‹ -->
            <div class="tool-section">
                <h2>ğŸ¯ SSRFé£é™©æ£€æµ‹</h2>
                <input type="text" id="ssrfUrl" value="https://api.internal/service" placeholder="å†…éƒ¨URL">
                <button onclick="detectSSRF()">æ£€æµ‹SSRFé£é™©</button>
                <div class="result" id="ssrfResult"></div>
            </div>

            <!-- å·¥å…·4: URLæ··æ·†æ£€æµ‹ -->
            <div class="tool-section">
                <h2>ğŸ­ URLæ··æ·†æ£€æµ‹</h2>
                <input type="text" id="obfuscatedUrl" value="https://exÃ¤mple.com@evil.com" placeholder="å¯ç–‘URL">
                <button onclick="detectObfuscation()">æ£€æµ‹æ··æ·†</button>
                <div class="result" id="obfuscationResult"></div>
            </div>
        </div>
    </div>

    <!-- åè®®åˆ†ææ ‡ç­¾é¡µ -->
    <div id="protocol-tab" class="tab-content">
        <div class="grid">
            <!-- å·¥å…·5: HTTPæ ‡å¤´åˆ†æ -->
            <div class="tool-section">
                <h2>ğŸ“‹ HTTPæ ‡å¤´æ¨¡æ‹Ÿ</h2>
                <select id="headerMethod">
                    <option>GET</option>
                    <option>POST</option>
                    <option>HEAD</option>
                    <option>PUT</option>
                    <option>DELETE</option>
                </select>
                <textarea id="customHeaders" placeholder="è‡ªå®šä¹‰æ ‡å¤´ (æ¯è¡Œä¸€ä¸ª Header: Value)">User-Agent: ExpertURLTool/1.0
Accept: application/json
Cache-Control: no-cache</textarea>
                <button onclick="simulateRequest()">æ¨¡æ‹Ÿè¯·æ±‚</button>
                <div class="result" id="headersResult"></div>
            </div>

            <!-- å·¥å…·6: åè®®å‡çº§åˆ†æ -->
            <div class="tool-section">
                <h2>ğŸ”„ åè®®å‡çº§åˆ†æ</h2>
                <input type="text" id="upgradeUrl" placeholder="è¾“å…¥URL">
                <button onclick="analyzeUpgrade()">åˆ†æåè®®å‡çº§</button>
                <div class="result" id="upgradeResult"></div>
            </div>

            <!-- å·¥å…·7: WebSocket URLåˆ†æ -->
            <div class="tool-section">
                <h2>âš¡ WebSocket URLåˆ†æ</h2>
                <input type="text" id="wsUrl" value="wss://example.com/ws" placeholder="WebSocket URL">
                <button onclick="analyzeWebSocket()">åˆ†æWebSocket</button>
                <div class="result" id="wsResult"></div>
            </div>
        </div>
    </div>

    <!-- ç»“æ„åˆ†ææ ‡ç­¾é¡µ -->
    <div id="structure-tab" class="tab-content">
        <div class="grid">
            <!-- å·¥å…·8: URLè§„èŒƒåŒ– -->
            <div class="tool-section">
                <h2>ğŸ“ URLè§„èŒƒåŒ–</h2>
                <select id="normalizationType">
                    <option value="full">å®Œæ•´è§„èŒƒåŒ–</option>
                    <option value="path">è·¯å¾„è§„èŒƒåŒ–</option>
                    <option value="case">å¤§å°å†™è§„èŒƒåŒ–</option>
                    <option value="encoding">ç¼–ç è§„èŒƒåŒ–</option>
                </select>
                <input type="text" id="normalizeUrl" value="HTTPS://Example.com/.././path//to%20page?q=test">
                <button onclick="normalizeURL()">è§„èŒƒåŒ–URL</button>
                <div class="result" id="normalizeResult"></div>
            </div>

            <!-- å·¥å…·9: å›½é™…åŸŸååˆ†æ -->
            <div class="tool-section">
                <h2>ğŸŒ å›½é™…åŸŸå(IDN)åˆ†æ</h2>
                <input type="text" id="idnUrl" value="https://ä¾‹ãˆ.ãƒ†ã‚¹ãƒˆ" placeholder="å›½é™…åŒ–åŸŸå">
                <button onclick="analyzeIDN()">åˆ†æIDN</button>
                <div class="result" id="idnResult"></div>
            </div>

            <!-- å·¥å…·10: URLè·¯å¾„éå†æ£€æµ‹ -->
            <div class="tool-section">
                <h2>ğŸ”„ è·¯å¾„éå†æ£€æµ‹</h2>
                <input type="text" id="traversalUrl" value="https://example.com/files/../../etc/passwd" placeholder="URLè·¯å¾„">
                <button onclick="detectTraversal()">æ£€æµ‹éå†</button>
                <div class="result" id="traversalResult"></div>
            </div>
        </div>
    </div>

    <!-- é«˜çº§å·¥å…·æ ‡ç­¾é¡µ -->
    <div id="advanced-tab" class="tab-content">
        <div class="grid">
            <!-- å·¥å…·11: URLç­¾åç”Ÿæˆ -->
            <div class="tool-section">
                <h2>ğŸ”‘ URLç­¾åç”Ÿæˆ</h2>
                <div class="param-row">
                    <input type="text" id="signUrl" placeholder="è¦ç­¾åçš„URL" style="grid-column: 1 / 4;">
                </div>
                <div class="param-row">
                    <input type="text" id="secretKey" value="my-secret-key" placeholder="å¯†é’¥">
                    <select id="hashAlgo">
                        <option>HMAC-SHA256</option>
                        <option>HMAC-SHA1</option>
                        <option>HMAC-MD5</option>
                    </select>
                    <button onclick="signURL()">ç”Ÿæˆç­¾å</button>
                </div>
                <div class="result" id="signResult"></div>
            </div>

            <!-- å·¥å…·12: Bloom Filter URLæ£€æµ‹ -->
            <div class="tool-section">
                <h2>ğŸŒ¸ Bloom Filteræ£€æµ‹</h2>
                <textarea id="bloomUrls" placeholder="è¾“å…¥URLåˆ—è¡¨ (æ¯è¡Œä¸€ä¸ª)">https://example.com/page1
https://example.com/page2
https://test.com/api
https://example.com/page1
https://newdomain.com</textarea>
                <button onclick="bloomFilterTest()">Bloom Filteræ£€æµ‹</button>
                <div class="result" id="bloomResult"></div>
            </div>

            <!-- å·¥å…·13: URLç†µå€¼åˆ†æ -->
            <div class="tool-section">
                <h2>ğŸ“Š URLç†µå€¼åˆ†æ</h2>
                <input type="text" id="entropyUrl" placeholder="è¾“å…¥URL">
                <button onclick="analyzeEntropy()">è®¡ç®—ç†µå€¼</button>
                <div class="result" id="entropyResult"></div>
            </div>

            <!-- å·¥å…·14: å·®åˆ†URLåˆ†æ -->
            <div class="tool-section">
                <h2>ğŸ”¬ å·®åˆ†URLåˆ†æ</h2>
                <div class="param-row">
                    <input type="text" id="diffUrl1" value="https://example.com/v1/api?q=test" placeholder="URL1">
                    <input type="text" id="diffUrl2" value="https://example.com/v2/api?q=test" placeholder="URL2">
                    <button onclick="diffURLs()">åˆ†æå·®å¼‚</button>
                </div>
                <div class="result" id="diffResult"></div>
            </div>
        </div>
    </div>

    <script>
        // æ ‡ç­¾é¡µåˆ‡æ¢
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // å·¥å…·1: URLæ³¨å…¥æ£€æµ‹
        function detectInjection() {
            const url = document.getElementById('injectionUrl').value;
            const result = document.getElementById('injectionResult');
            
            try {
                const urlObj = new URL(url);
                let vulnerabilities = [];
                
                // XSSæ£€æµ‹
                const xssPatterns = [
                    /<script>/i, /javascript:/i, /onload=/i, /onerror=/i,
                    /onclick=/i, /onmouseover=/i, /alert\(/i, /eval\(/i
                ];
                
                // SQLæ³¨å…¥æ£€æµ‹
                const sqlPatterns = [
                    /union.*select/i, /select.*from/i, /insert.*into/i,
                    /update.*set/i, /delete.*from/i, /drop.*table/i,
                    /1=1/, /' OR '1'='1/, /--\s*$/, /\/\*.*\*\//,
                    /exec\(/i, /xp_cmdshell/i
                ];
                
                // ç›®å½•éå†æ£€æµ‹
                const traversalPatterns = [
                    /\.\.\//, /\.\.\\/, /etc\/passwd/, /win\.ini/,
                    /\.\.%2f/, /\.\.%5c/, /%2e%2e%2f/
                ];
                
                // å‘½ä»¤æ³¨å…¥æ£€æµ‹
                const cmdPatterns = [
                    /\|.*ls/, /\|.*cat/, /\|.*rm/, /;.*ls/, /;.*cat/,
                    /\|\|.*ping/, /&&.*ping/, /`.*`/, /\$\(.*\)/
                ];
                
                // é‡å®šå‘æ£€æµ‹
                const redirectPatterns = [
                    /redirect=/i, /return=/i, /url=/i, /next=/i,
                    /goto=/i, /link=/i, /dest=/i, /target=/i
                ];
                
                // æ£€æŸ¥æ•´ä¸ªURL
                const urlString = urlObj.href;
                const searchParams = urlObj.search;
                
                vulnerabilities = detectPatterns('XSS', xssPatterns, urlString, vulnerabilities);
                vulnerabilities = detectPatterns('SQLæ³¨å…¥', sqlPatterns, urlString, vulnerabilities);
                vulnerabilities = detectPatterns('è·¯å¾„éå†', traversalPatterns, urlString, vulnerabilities);
                vulnerabilities = detectPatterns('å‘½ä»¤æ³¨å…¥', cmdPatterns, urlString, vulnerabilities);
                vulnerabilities = detectPatterns('å¼€æ”¾é‡å®šå‘', redirectPatterns, searchParams, vulnerabilities);
                
                // æ£€æŸ¥ç¼–ç ç»•è¿‡
                const encodedUrl = encodeURIComponent(url);
                if (encodedUrl.includes('%3c') || encodedUrl.includes('%3e')) {
                    vulnerabilities.push('ç¼–ç çš„HTMLæ ‡ç­¾æ£€æµ‹');
                }
                
                // è¾“å‡ºç»“æœ
                let output = 'ğŸ” URLæ³¨å…¥æ£€æµ‹æŠ¥å‘Š\n\n';
                output += `ç›®æ ‡URL: ${urlObj.href}\n`;
                output += `åè®®: ${urlObj.protocol}\n`;
                output += `ä¸»æœº: ${urlObj.host}\n`;
                output += `è·¯å¾„: ${urlObj.pathname}\n\n`;
                
                if (vulnerabilities.length > 0) {
                    output += 'âš ï¸ å‘ç°æ½œåœ¨å®‰å…¨é£é™©:\n';
                    vulnerabilities.forEach(vuln => {
                        output += `  â€¢ ${vuln}\n`;
                    });
                    output += `\né£é™©ç­‰çº§: ${vulnerabilities.length > 3 ? 'é«˜' : 'ä¸­'}`;
                } else {
                    output += 'âœ… æœªå‘ç°æ˜æ˜¾çš„æ³¨å…¥é£é™©';
                }
                
                // é¢å¤–å»ºè®®
                output += '\n\nğŸ’¡ å®‰å…¨å»ºè®®:';
                output += '\n1. å¯¹æ‰€æœ‰è¾“å…¥è¿›è¡ŒéªŒè¯å’Œæ¸…ç†';
                output += '\n2. ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥';
                output += '\n3. å®æ–½é€‚å½“çš„è¾“å‡ºç¼–ç ';
                output += '\n4. éªŒè¯é‡å®šå‘ç›®æ ‡';
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // æ¨¡å¼æ£€æµ‹è¾…åŠ©å‡½æ•°
        function detectPatterns(name, patterns, text, vulnerabilities) {
            patterns.forEach(pattern => {
                if (pattern.test(text)) {
                    vulnerabilities.push(`${name}æ£€æµ‹ (æ¨¡å¼: ${pattern.toString()})`);
                }
            });
            return vulnerabilities;
        }

        // å·¥å…·2: åŒæºç­–ç•¥åˆ†æ
        function analyzeCORS() {
            const origin1 = document.getElementById('origin1').value;
            const origin2 = document.getElementById('origin2').value;
            const result = document.getElementById('corsResult');
            
            try {
                const url1 = new URL(origin1);
                const url2 = new URL(origin2);
                
                let output = 'ğŸŒ åŒæºç­–ç•¥åˆ†æ\n\n';
                output += `æº1: ${url1.origin}\n`;
                output += `æº2: ${url2.origin}\n\n`;
                
                const sameOrigin = url1.origin === url2.origin;
                output += `åŒæº: ${sameOrigin ? 'âœ… æ˜¯' : 'âŒ å¦'}\n\n`;
                
                if (!sameOrigin) {
                    output += 'ğŸ” å·®å¼‚åˆ†æ:\n';
                    output += `åè®®: ${url1.protocol} vs ${url2.protocol} ${url1.protocol === url2.protocol ? 'âœ…' : 'âŒ'}\n`;
                    output += `ä¸»æœºå: ${url1.hostname} vs ${url2.hostname} ${url1.hostname === url2.hostname ? 'âœ…' : 'âŒ'}\n`;
                    output += `ç«¯å£: ${url1.port || 'é»˜è®¤'} vs ${url2.port || 'é»˜è®¤'} ${url1.port === url2.port ? 'âœ…' : 'âŒ'}\n\n`;
                    
                    // CORSé¢„æ£€è¯·æ±‚åˆ†æ
                    output += 'ğŸ“‹ CORSé¢„æ£€è¯·æ±‚è¦æ±‚:\n';
                    output += '1. ä½¿ç”¨ç®€å•æ–¹æ³•(GET, POST, HEAD)ä»¥å¤–çš„HTTPæ–¹æ³•\n';
                    output += '2. è®¾ç½®è‡ªå®šä¹‰æ ‡å¤´\n';
                    output += '3. å‘é€å‡­æ®(cookies)\n';
                    output += '4. ä½¿ç”¨éç®€å•Content-Type\n\n';
                    
                    output += 'ğŸ”§ å¯èƒ½çš„CORSé…ç½®:\n';
                    output += 'Access-Control-Allow-Origin: * (å…è®¸æ‰€æœ‰æº)\n';
                    output += `Access-Control-Allow-Origin: ${url1.origin} (å…è®¸ç‰¹å®šæº)\n`;
                    output += 'Access-Control-Allow-Credentials: true (å…è®¸å‡­æ®)\n';
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: è¯·è¾“å…¥æœ‰æ•ˆçš„URL';
            }
        }

        // å·¥å…·3: SSRFé£é™©æ£€æµ‹
        function detectSSRF() {
            const url = document.getElementById('ssrfUrl').value;
            const result = document.getElementById('ssrfResult');
            
            try {
                const urlObj = new URL(url);
                let risks = [];
                
                // å†…éƒ¨IPåœ°å€æ£€æµ‹
                const internalIPs = [
                    /^10\./, /^172\.(1[6-9]|2[0-9]|3[0-1])\./, /^192\.168\./,
                    /^127\./, /^169\.254\./, /^0\./, /^localhost$/,
                    /^::1$/, /^fc00::/, /^fd00::/
                ];
                
                // äº‘æœåŠ¡å…ƒæ•°æ®ç«¯ç‚¹
                const cloudMetadata = [
                    '169.254.169.254', 'metadata.google.internal',
                    '169.254.170.2', 'instance-data'
                ];
                
                // æ£€æŸ¥å†…éƒ¨IP
                internalIPs.forEach(pattern => {
                    if (pattern.test(urlObj.hostname)) {
                        risks.push('å†…éƒ¨IPåœ°å€æ£€æµ‹');
                    }
                });
                
                // æ£€æŸ¥äº‘å…ƒæ•°æ®
                cloudMetadata.forEach(endpoint => {
                    if (urlObj.hostname.includes(endpoint)) {
                        risks.push('äº‘æœåŠ¡å…ƒæ•°æ®ç«¯ç‚¹æ£€æµ‹');
                    }
                });
                
                // æ£€æŸ¥ç§æœ‰åŸŸå
                const privateTLDs = ['.local', '.internal', '.lan', '.home'];
                privateTLDs.forEach(tld => {
                    if (urlObj.hostname.endsWith(tld)) {
                        risks.push('ç§æœ‰åŸŸåæ£€æµ‹');
                    }
                });
                
                let output = 'ğŸ¯ SSRF(æœåŠ¡å™¨ç«¯è¯·æ±‚ä¼ªé€ )é£é™©æ£€æµ‹\n\n';
                output += `ç›®æ ‡URL: ${urlObj.href}\n`;
                output += `ä¸»æœºå: ${urlObj.hostname}\n`;
                output += `åè®®: ${urlObj.protocol}\n\n`;
                
                if (risks.length > 0) {
                    output += 'âš ï¸ é«˜é£é™©æ£€æµ‹:\n';
                    risks.forEach(risk => output += `  â€¢ ${risk}\n`);
                    
                    output += '\nğŸ›¡ï¸ é˜²æŠ¤å»ºè®®:\n';
                    output += '1. å®æ–½URLç™½åå•éªŒè¯\n';
                    output += '2. ä½¿ç”¨DNSè§£æé™åˆ¶\n';
                    output += '3. ç¦æ­¢è®¿é—®å†…éƒ¨ç½‘ç»œ\n';
                    output += '4. å®æ–½è¯·æ±‚åè®®é™åˆ¶\n';
                    output += '5. ä½¿ç”¨ä¸­é—´ä»£ç†è¿›è¡Œè¯·æ±‚\n';
                } else {
                    output += 'âœ… æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„SSRFé£é™©\n\n';
                    output += 'âš ï¸ ä»å»ºè®®å®æ–½é˜²æŠ¤æªæ–½:\n';
                    output += '- éªŒè¯æ‰€æœ‰å¤–éƒ¨URL\n';
                    output += '- é™åˆ¶å¯è®¿é—®çš„åè®®\n';
                    output += '- ç›‘æ§å¼‚å¸¸è¯·æ±‚æ¨¡å¼';
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·4: URLæ··æ·†æ£€æµ‹
        function detectObfuscation() {
            const url = document.getElementById('obfuscatedUrl').value;
            const result = document.getElementById('obfuscationResult');
            
            try {
                const urlObj = new URL(url);
                let techniques = [];
                
                // æ£€æŸ¥Unicodeæ··æ·†(åŒå½¢å¼‚ä¹‰å­—ç¬¦)
                const homoglyphs = /[Ğ°-ÑĞ-Ğ¯Ñ Ñ¡Ñ¢Ñ£Ñ¤Ñ¥Ñ¦Ñ§Ñ¨Ñ©ÑªÑ«Ñ¬Ñ­Ñ®Ñ¯Ñ°Ñ±Ñ²Ñ³Ñ´ÑµÒÒ‘]/;
                if (homoglyphs.test(url)) {
                    techniques.push('è¥¿é‡Œå°”å­—æ¯æ··æ·†æ£€æµ‹');
                }
                
                // æ£€æŸ¥URLç¼–ç æ··æ·†
                const doubleEncoded = /%25[0-9a-f]{2}/i;
                if (doubleEncoded.test(url)) {
                    techniques.push('åŒé‡URLç¼–ç æ£€æµ‹');
                }
                
                // æ£€æŸ¥åå…­è¿›åˆ¶ç¼–ç 
                const hexEncoded = /\\x[0-9a-f]{2}/gi;
                if (hexEncoded.test(url)) {
                    techniques.push('åå…­è¿›åˆ¶ç¼–ç æ£€æµ‹');
                }
                
                // æ£€æŸ¥å…«è¿›åˆ¶ç¼–ç 
                const octalEncoded = /\\[0-7]{3}/g;
                if (octalEncoded.test(url)) {
                    techniques.push('å…«è¿›åˆ¶ç¼–ç æ£€æµ‹');
                }
                
                // æ£€æŸ¥@ç¬¦å·æ··æ·†
                const atConfusion = /@/;
                if (atConfusion.test(url)) {
                    const parts = url.split('@');
                    if (parts.length > 2) {
                        techniques.push('å¤šä¸ª@ç¬¦å·æ··æ·†');
                    }
                }
                
                // æ£€æŸ¥IPæ··æ·†
                const ipFormats = [
                    /^(\d{1,3}\.){3}\d{1,3}$/, // IPv4
                    /^[0-9a-f:]+$/i, // IPv6
                    /^\d+$/, // åè¿›åˆ¶IP
                    /^0x[0-9a-f]+$/i, // åå…­è¿›åˆ¶IP
                    /^0[0-7]+$/, // å…«è¿›åˆ¶IP
                    /^\[.*\]$/ // IPv6æ‹¬å·æ ¼å¼
                ];
                
                ipFormats.forEach(format => {
                    if (format.test(urlObj.hostname)) {
                        techniques.push('IPåœ°å€æ ¼å¼æ£€æµ‹');
                    }
                });
                
                let output = 'ğŸ­ URLæ··æ·†æŠ€æœ¯æ£€æµ‹\n\n';
                output += `åŸå§‹URL: ${url}\n`;
                output += `è§£æå: ${urlObj.href}\n\n`;
                
                // æ˜¾ç¤ºè§„èŒƒåŒ–åçš„URL
                const normalized = url.toLowerCase()
                    .replace(/\/\/+/g, '/')
                    .replace(/\/$/, '');
                output += `è§„èŒƒåŒ–: ${normalized}\n\n`;
                
                if (techniques.length > 0) {
                    output += 'âš ï¸ æ£€æµ‹åˆ°æ··æ·†æŠ€æœ¯:\n';
                    techniques.forEach(tech => output += `  â€¢ ${tech}\n`);
                    
                    output += '\nğŸ” è¯¦ç»†åˆ†æ:\n';
                    
                    // æ˜¾ç¤ºå­—ç¬¦åˆ†æ
                    output += '\nå­—ç¬¦åˆ†æ:\n';
                    for (let i = 0; i < Math.min(url.length, 50); i++) {
                        const char = url[i];
                        const code = char.charCodeAt(0);
                        output += `${char} (U+${code.toString(16).toUpperCase().padStart(4, '0')}) `;
                        if ((i + 1) % 5 === 0) output += '\n';
                    }
                    
                    output += '\n\nğŸ›¡ï¸ é˜²æŠ¤å»ºè®®:\n';
                    output += '1. å®æ–½ä¸¥æ ¼çš„URLéªŒè¯\n';
                    output += '2. è§„èŒƒåŒ–æ‰€æœ‰è¾“å…¥URL\n';
                    output += '3. ä½¿ç”¨Unicodeè§„èŒƒåŒ–(NFKC)\n';
                    output += '4. æ£€æŸ¥åŸŸåç™½åå•\n';
                    output += '5. è®°å½•å¯ç–‘URLæ¨¡å¼';
                } else {
                    output += 'âœ… æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„æ··æ·†æŠ€æœ¯';
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·5: HTTPæ ‡å¤´æ¨¡æ‹Ÿ
        function simulateRequest() {
            const method = document.getElementById('headerMethod').value;
            const headersText = document.getElementById('customHeaders').value;
            const result = document.getElementById('headersResult');
            
            const url = document.getElementById('masterUrl').value || 'https://example.com';
            
            try {
                const urlObj = new URL(url);
                const headers = {};
                
                // è§£æè‡ªå®šä¹‰æ ‡å¤´
                headersText.split('\n').forEach(line => {
                    const trimmed = line.trim();
                    if (trimmed && trimmed.includes(':')) {
                        const [key, ...valueParts] = trimmed.split(':');
                        headers[key.trim()] = valueParts.join(':').trim();
                    }
                });
                
                // æ·»åŠ å¸¸ç”¨æ ‡å¤´
                const defaultHeaders = {
                    'Host': urlObj.host,
                    'Connection': 'keep-alive',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'
                };
                
                const allHeaders = { ...defaultHeaders, ...headers };
                
                let output = `ğŸ“‹ ${method} è¯·æ±‚æ¨¡æ‹Ÿ\n\n`;
                output += `ç›®æ ‡URL: ${urlObj.href}\n`;
                output += `è¯·æ±‚æ–¹æ³•: ${method}\n\n`;
                
                output += 'è¯·æ±‚æ ‡å¤´:\n';
                output += 'â”€'.repeat(50) + '\n';
                
                for (const [key, value] of Object.entries(allHeaders)) {
                    output += `${key}: ${value}\n`;
                }
                
                // æ˜¾ç¤ºcurlå‘½ä»¤
                output += '\nCURLå‘½ä»¤:\n';
                output += 'â”€'.repeat(50) + '\n';
                let curlCmd = `curl -X ${method} "${urlObj.href}"`;
                for (const [key, value] of Object.entries(headers)) {
                    curlCmd += ` \\\n  -H "${key}: ${value}"`;
                }
                output += curlCmd;
                
                // å®‰å…¨æ ‡å¤´å»ºè®®
                output += '\n\nğŸ”’ å»ºè®®çš„å®‰å…¨æ ‡å¤´:\n';
                output += 'â”€'.repeat(50) + '\n';
                const securityHeaders = {
                    'Content-Security-Policy': "default-src 'self'",
                    'X-Content-Type-Options': 'nosniff',
                    'X-Frame-Options': 'DENY',
                    'X-XSS-Protection': '1; mode=block',
                    'Referrer-Policy': 'strict-origin-when-cross-origin',
                    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'
                };
                
                for (const [key, value] of Object.entries(securityHeaders)) {
                    output += `${key}: ${value}\n`;
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·6: åè®®å‡çº§åˆ†æ
        function analyzeUpgrade() {
            const url = document.getElementById('upgradeUrl').value || document.getElementById('masterUrl').value;
            const result = document.getElementById('upgradeResult');
            
            try {
                const urlObj = new URL(url);
                
                let output = 'ğŸ”„ åè®®å‡çº§åˆ†æ\n\n';
                output += `å½“å‰åè®®: ${urlObj.protocol}\n\n`;
                
                // HTTP -> HTTPSå‡çº§
                if (urlObj.protocol === 'http:') {
                    const httpsUrl = url.replace('http:', 'https:');
                    output += `å»ºè®®å‡çº§: ${httpsUrl}\n\n`;
                    
                    output += 'å‡çº§æ£€æŸ¥:\n';
                    output += 'â”€'.repeat(50) + '\n';
                    output += '1. æ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæ€§\n';
                    output += '2. éªŒè¯HSTSå¤´\n';
                    output += '3. æ›´æ–°æ‰€æœ‰å†…éƒ¨é“¾æ¥\n';
                    output += '4. è®¾ç½®301é‡å®šå‘\n';
                    output += '5. æ›´æ–°XMLç«™ç‚¹åœ°å›¾\n\n';
                }
                
                // WebSocketå‡çº§
                output += 'WebSocketåè®®:\n';
                output += 'â”€'.repeat(50) + '\n';
                const wsUrl = url.replace(/^http/, 'ws').replace(/^https/, 'wss');
                output += `WebSocket URL: ${wsUrl}\n\n`;
                
                // åè®®ç‰¹æ€§å¯¹æ¯”
                output += 'åè®®ç‰¹æ€§å¯¹æ¯”:\n';
                output += 'â”€'.repeat(50) + '\n';
                const protocols = [
                    { name: 'HTTP/1.1', features: 'æŒä¹…è¿æ¥, ç®¡é“åŒ–', security: 'åŸºç¡€' },
                    { name: 'HTTP/2', features: 'å¤šè·¯å¤ç”¨, å¤´éƒ¨å‹ç¼©', security: 'TLSæ¨è' },
                    { name: 'HTTP/3', features: 'QUIC, 0-RTT', security: 'å¼ºåˆ¶TLS' },
                    { name: 'WebSocket', features: 'å…¨åŒå·¥, å®æ—¶', security: 'éœ€è¦TLS' }
                ];
                
                protocols.forEach(proto => {
                    output += `${proto.name.padEnd(10)} | ${proto.features.padEnd(25)} | ${proto.security}\n`;
                });
                
                // å‡çº§ç­–ç•¥
                output += '\nå‡çº§ç­–ç•¥å»ºè®®:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += '1. å®æ–½é€æ­¥å‡çº§\n';
                output += '2. ä½¿ç”¨åè®®æ£€æµ‹\n';
                output += '3. ä¿æŒå‘åå…¼å®¹\n';
                output += '4. ç›‘æ§æ€§èƒ½å½±å“\n';
                output += '5. æµ‹è¯•ä¸­æ–­æƒ…å†µ\n';
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·7: WebSocket URLåˆ†æ
        function analyzeWebSocket() {
            const url = document.getElementById('wsUrl').value;
            const result = document.getElementById('wsResult');
            
            try {
                const urlObj = new URL(url);
                const isSecure = urlObj.protocol === 'wss:';
                const isWebSocket = urlObj.protocol === 'ws:' || isSecure;
                
                let output = 'âš¡ WebSocket URLåˆ†æ\n\n';
                output += `URL: ${url}\n`;
                output += `åè®®: ${urlObj.protocol}\n`;
                output += `å®‰å…¨: ${isSecure ? 'âœ… WSS (å®‰å…¨)' : 'âš ï¸ WS (ä¸å®‰å…¨)'}\n`;
                output += `ä¸»æœº: ${urlObj.host}\n`;
                output += `è·¯å¾„: ${urlObj.pathname}\n\n`;
                
                if (!isWebSocket) {
                    output += 'âŒ ä¸æ˜¯WebSocketåè®®\n';
                    const suggested = url.replace(/^http/, 'ws').replace(/^https/, 'wss');
                    output += `å»ºè®®: ${suggested}`;
                    result.textContent = output;
                    return;
                }
                
                // WebSocketç‰¹å®šåˆ†æ
                output += 'ğŸ”Œ WebSocketè¿æ¥å‚æ•°:\n';
                output += 'â”€'.repeat(50) + '\n';
                
                const params = new URLSearchParams(urlObj.search);
                if (params.toString()) {
                    output += 'æŸ¥è¯¢å‚æ•°:\n';
                    for (const [key, value] of params) {
                        output += `  ${key}=${value}\n`;
                    }
                } else {
                    output += 'æ— æŸ¥è¯¢å‚æ•°\n';
                }
                
                // WebSocketæ¡æ‰‹ç¤ºä¾‹
                output += '\nğŸ¤ WebSocketæ¡æ‰‹ç¤ºä¾‹:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += 'å®¢æˆ·ç«¯è¯·æ±‚:\n';
                output += `GET ${urlObj.pathname}${urlObj.search} HTTP/1.1\n`;
                output += `Host: ${urlObj.host}\n`;
                output += 'Upgrade: websocket\n';
                output += 'Connection: Upgrade\n';
                output += 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n';
                output += 'Sec-WebSocket-Version: 13\n\n';
                
                output += 'æœåŠ¡å™¨å“åº”:\n';
                output += 'HTTP/1.1 101 Switching Protocols\n';
                output += 'Upgrade: websocket\n';
                output += 'Connection: Upgrade\n';
                output += 'Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n';
                
                // å®‰å…¨å»ºè®®
                output += '\nğŸ”’ WebSocketå®‰å…¨å»ºè®®:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += '1. å§‹ç»ˆä½¿ç”¨WSS (WebSocket Secure)\n';
                output += '2. éªŒè¯Originå¤´\n';
                output += '3. å®æ–½è®¤è¯å’Œæˆæƒ\n';
                output += '4. é™åˆ¶æ¶ˆæ¯å¤§å°å’Œé¢‘ç‡\n';
                output += '5. ç›‘æ§è¿æ¥çŠ¶æ€\n';
                output += '6. ä½¿ç”¨å¿ƒè·³æœºåˆ¶æ£€æµ‹æ­»è¿æ¥\n';
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·8: URLè§„èŒƒåŒ–
        function normalizeURL() {
            const url = document.getElementById('normalizeUrl').value;
            const type = document.getElementById('normalizationType').value;
            const result = document.getElementById('normalizeResult');
            
            try {
                let normalized = url;
                let steps = [];
                
                // å®Œæ•´è§„èŒƒåŒ–
                if (type === 'full' || type === 'path') {
                    // ç§»é™¤å¤šä½™æ–œæ 
                    normalized = normalized.replace(/\/\/+/g, '/');
                    steps.push('ç§»é™¤å¤šä½™æ–œæ ');
                    
                    // è§£æè·¯å¾„éå†
                    const pathParts = normalized.split('/');
                    const newParts = [];
                    
                    for (const part of pathParts) {
                        if (part === '..') {
                            if (newParts.length > 0) {
                                newParts.pop();
                                steps.push('è§£æ..ä¸Šä¸€çº§ç›®å½•');
                            }
                        } else if (part !== '.' && part !== '') {
                            newParts.push(part);
                        } else if (part === '.') {
                            steps.push('ç§»é™¤.å½“å‰ç›®å½•');
                        }
                    }
                    
                    normalized = newParts.join('/');
                    if (!normalized.startsWith('/') && normalized.includes('/')) {
                        normalized = '/' + normalized;
                    }
                }
                
                // å¤§å°å†™è§„èŒƒåŒ–
                if (type === 'full' || type === 'case') {
                    const urlObj = new URL(normalized.startsWith('http') ? normalized : 'http://' + normalized);
                    const lowerHost = urlObj.hostname.toLowerCase();
                    
                    if (urlObj.hostname !== lowerHost) {
                        steps.push('ä¸»æœºåè½¬æ¢ä¸ºå°å†™');
                        normalized = normalized.replace(urlObj.hostname, lowerHost);
                    }
                }
                
                // ç¼–ç è§„èŒƒåŒ–
                if (type === 'full' || type === 'encoding') {
                    // è§£ç ç„¶åé‡æ–°ç¼–ç 
                    try {
                        const decoded = decodeURIComponent(normalized);
                        const reencoded = encodeURI(decoded);
                        if (normalized !== reencoded) {
                            steps.push('æ ‡å‡†åŒ–URLç¼–ç ');
                            normalized = reencoded;
                        }
                    } catch (e) {
                        // å¦‚æœè§£ç å¤±è´¥ï¼Œå°è¯•éƒ¨åˆ†è§£ç 
                    }
                    
                    // æ ‡å‡†åŒ–ç©ºæ ¼ç¼–ç 
                    normalized = normalized.replace(/%20/g, '+');
                    steps.push('æ ‡å‡†åŒ–ç©ºæ ¼ç¼–ç ä¸º+');
                }
                
                let output = `ğŸ“ URLè§„èŒƒåŒ– (${type})\n\n`;
                output += `åŸå§‹URL: ${url}\n`;
                output += `è§„èŒƒåŒ–å: ${normalized}\n\n`;
                
                if (steps.length > 0) {
                    output += 'æ‰§è¡Œæ­¥éª¤:\n';
                    steps.forEach(step => output += `  â€¢ ${step}\n`);
                } else {
                    output += 'æ— éœ€è§„èŒƒåŒ–æ“ä½œ\n';
                }
                
                // éªŒè¯è§„èŒƒåŒ–ç»“æœ
                output += '\néªŒè¯ç»“æœ:\n';
                try {
                    const urlObj = new URL(normalized.startsWith('http') ? normalized : 'https://' + normalized);
                    output += 'âœ… URLæœ‰æ•ˆ\n';
                    output += `åè®®: ${urlObj.protocol}\n`;
                    output += `ä¸»æœº: ${urlObj.host}\n`;
                    output += `è·¯å¾„: ${urlObj.pathname}\n`;
                } catch (e) {
                    output += `âŒ URLæ— æ•ˆ: ${e.message}\n`;
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·9: å›½é™…åŸŸååˆ†æ
        function analyzeIDN() {
            const url = document.getElementById('idnUrl').value;
            const result = document.getElementById('idnResult');
            
            try {
                const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url);
                const hostname = urlObj.hostname;
                
                let output = 'ğŸŒ å›½é™…åŸŸå(IDN)åˆ†æ\n\n';
                output += `åŸå§‹åŸŸå: ${hostname}\n`;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯IDN
                const hasNonASCII = /[^\x00-\x7F]/.test(hostname);
                
                if (hasNonASCII) {
                    output += 'æ£€æµ‹åˆ°éASCIIå­—ç¬¦\n\n';
                    
                    // è½¬æ¢ä¸ºPunycode
                    try {
                        const punycode = hostname.toLowerCase().normalize('NFC');
                        const encoded = 'xn--' + btoa(unescape(encodeURIComponent(punycode))).replace(/[+/=]/g, '').toLowerCase();
                        
                        output += 'Punycodeç¼–ç :\n';
                        output += `  ${encoded}\n\n`;
                        
                        // æ˜¾ç¤ºUnicodeåˆ†æ
                        output += 'Unicodeå­—ç¬¦åˆ†æ:\n';
                        for (let i = 0; i < hostname.length; i++) {
                            const char = hostname[i];
                            const code = char.charCodeAt(0);
                            const hex = code.toString(16).toUpperCase();
                            
                            output += `  ${char} (U+${hex.padStart(4, '0')})`;
                            
                            // æ£€æŸ¥åŒå½¢å¼‚ä¹‰å­—ç¬¦
                            const homoglyphs = {
                                'Ğ°': 'a', 'Ğµ': 'e', 'Ğ¾': 'o', 'Ñ€': 'p',
                                'Ñ': 'c', 'Ñƒ': 'y', 'Ñ…': 'x', 'Ñ–': 'i'
                            };
                            
                            if (homoglyphs[char]) {
                                output += ` â†’ ç±»ä¼¼äºæ‹‰ä¸å­—æ¯ "${homoglyphs[char]}"`;
                            }
                            
                            output += '\n';
                        }
                        
                        // å®‰å…¨è­¦å‘Š
                        output += '\nâš ï¸ å®‰å…¨è­¦å‘Š:\n';
                        output += 'IDNå¯èƒ½è¢«ç”¨äºé’“é±¼æ”»å‡»:\n';
                        output += '1. åŒå½¢å¼‚ä¹‰å­—ç¬¦æ”»å‡»\n';
                        output += '2. è§†è§‰ç›¸ä¼¼åŸŸå\n';
                        output += '3. æ··åˆè„šæœ¬æ”»å‡»\n\n';
                        
                        output += 'ğŸ”’ é˜²æŠ¤å»ºè®®:\n';
                        output += 'â€¢ åœ¨åœ°å€æ æ˜¾ç¤ºPunycode\n';
                        output += 'â€¢ å®æ–½ä¸¥æ ¼çš„åŸŸåéªŒè¯\n';
                        output += 'â€¢ æ•™è‚²ç”¨æˆ·è¯†åˆ«å¯ç–‘åŸŸå\n';
                        
                    } catch (e) {
                        output += `Punycodeè½¬æ¢å¤±è´¥: ${e.message}\n`;
                    }
                } else {
                    output += 'æœªæ£€æµ‹åˆ°IDN (ä»…ASCIIå­—ç¬¦)\n';
                }
                
                // æµè§ˆå™¨å…¼å®¹æ€§
                output += '\nğŸŒ æµè§ˆå™¨å…¼å®¹æ€§:\n';
                output += 'â”€'.repeat(50) + '\n';
                const compatibility = [
                    { browser: 'Chrome', version: 'â‰¥ 7', support: 'âœ…' },
                    { browser: 'Firefox', version: 'â‰¥ 3.0', support: 'âœ…' },
                    { browser: 'Safari', version: 'â‰¥ 3.2', support: 'âœ…' },
                    { browser: 'Edge', version: 'æ‰€æœ‰ç‰ˆæœ¬', support: 'âœ…' },
                    { browser: 'IE', version: 'â‰¥ 7', support: 'âš ï¸ éƒ¨åˆ†' }
                ];
                
                compatibility.forEach(item => {
                    output += `${item.browser.padEnd(10)} ${item.version.padEnd(10)} ${item.support}\n`;
                });
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·10: è·¯å¾„éå†æ£€æµ‹
        function detectTraversal() {
            const url = document.getElementById('traversalUrl').value;
            const result = document.getElementById('traversalResult');
            
            try {
                const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url);
                const path = urlObj.pathname;
                
                let output = 'ğŸ”„ è·¯å¾„éå†æ£€æµ‹\n\n';
                output += `åŸå§‹è·¯å¾„: ${path}\n`;
                
                // æ£€æµ‹è·¯å¾„éå†æ¨¡å¼
                const traversalPatterns = [
                    /\.\.\//g,
                    /\.\.\\/g,
                    /\/\.\.\//g,
                    /\\\.\.\\/g,
                    /%2e%2e\//gi,
                    /%2e%2e\\/gi,
                    /\.%2e\//gi,
                    /\.%2e\\/gi
                ];
                
                let found = [];
                traversalPatterns.forEach((pattern, index) => {
                    const matches = path.match(pattern);
                    if (matches) {
                        found.push({
                            pattern: pattern.toString(),
                            matches: matches,
                            count: matches.length
                        });
                    }
                });
                
                if (found.length > 0) {
                    output += '\nâš ï¸ æ£€æµ‹åˆ°è·¯å¾„éå†å°è¯•:\n';
                    found.forEach(item => {
                        output += `  æ¨¡å¼: ${item.pattern}\n`;
                        output += `  åŒ¹é…: ${item.matches.join(', ')}\n`;
                        output += `  æ¬¡æ•°: ${item.count}\n\n`;
                    });
                    
                    // è§£ææœ€ç»ˆè·¯å¾„
                    output += 'å®é™…è®¿é—®è·¯å¾„:\n';
                    const parts = path.split(/[\/\\]/).filter(p => p);
                    const resolved = [];
                    
                    for (const part of parts) {
                        if (part === '..') {
                            if (resolved.length > 0) resolved.pop();
                        } else if (part !== '.') {
                            resolved.push(part);
                        }
                    }
                    
                    output += `  /${resolved.join('/')}\n\n`;
                    
                    // å®‰å…¨å»ºè®®
                    output += 'ğŸ”’ é˜²æŠ¤æªæ–½:\n';
                    output += '1. å®æ–½è¾“å…¥éªŒè¯\n';
                    output += '2. ä½¿ç”¨ç™½åå•æ–‡ä»¶è·¯å¾„\n';
                    output += '3. è§„èŒƒåŒ–è·¯å¾„åéªŒè¯\n';
                    output += '4. è®¾ç½®æ–‡ä»¶ç³»ç»Ÿæƒé™\n';
                    output += '5. è®°å½•å¯ç–‘è®¿é—®å°è¯•\n';
                    
                } else {
                    output += '\nâœ… æœªæ£€æµ‹åˆ°è·¯å¾„éå†\n\n';
                    
                    // ä»ç„¶æ˜¾ç¤ºè§„èŒƒåŒ–è·¯å¾„
                    const parts = path.split(/[\/\\]/).filter(p => p);
                    output += `è§„èŒƒåŒ–è·¯å¾„: /${parts.join('/')}\n`;
                }
                
                // å¸¸è§æ˜“å—æ”»å‡»çš„è·¯å¾„
                output += '\nğŸ¯ å¸¸è§æ”»å‡»ç›®æ ‡:\n';
                const targets = [
                    '/etc/passwd', '/etc/shadow', '/etc/hosts',
                    '/var/log/', '/proc/self/environ',
                    'C:\\Windows\\System32\\', '/WEB-INF/web.xml',
                    '.git/config', '.env', 'wp-config.php'
                ];
                
                targets.forEach(target => {
                    if (path.includes(target)) {
                        output += `âš ï¸ åŒ…å«æ•æ„Ÿè·¯å¾„: ${target}\n`;
                    }
                });
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·11: URLç­¾åç”Ÿæˆ
        function signURL() {
            const url = document.getElementById('signUrl').value || document.getElementById('masterUrl').value;
            const secret = document.getElementById('secretKey').value;
            const algo = document.getElementById('hashAlgo').value;
            const result = document.getElementById('signResult');
            
            try {
                const urlObj = new URL(url);
                
                // åˆ›å»ºç­¾åå‚æ•°
                const timestamp = Math.floor(Date.now() / 1000);
                const nonce = Math.random().toString(36).substring(2, 15);
                
                // æ·»åŠ ç­¾åå‚æ•°
                urlObj.searchParams.append('timestamp', timestamp);
                urlObj.searchParams.append('nonce', nonce);
                
                // å‡†å¤‡ç­¾åå­—ç¬¦ä¸²
                const params = new URLSearchParams(urlObj.search);
                params.sort(); // å‚æ•°æ’åº
                
                const signString = Array.from(params)
                    .map(([k, v]) => `${k}=${v}`)
                    .join('&');
                
                // ç”Ÿæˆç­¾å
                let signature = '';
                if (algo === 'HMAC-SHA256') {
                    // ç®€å•æ¨¡æ‹Ÿ - å®é™…åº”ä½¿ç”¨crypto API
                    signature = btoa(signString + secret).substring(0, 32);
                } else if (algo === 'HMAC-SHA1') {
                    signature = btoa(signString + secret).substring(0, 20);
                } else {
                    signature = btoa(signString + secret).substring(0, 16);
                }
                
                // æ·»åŠ ç­¾ååˆ°URL
                urlObj.searchParams.append('signature', signature);
                
                let output = `ğŸ”‘ URLç­¾åç”Ÿæˆ (${algo})\n\n`;
                output += `åŸå§‹URL: ${url}\n`;
                output += `å¯†é’¥: ${secret}\n`;
                output += `æ—¶é—´æˆ³: ${timestamp}\n`;
                output += `éšæœºæ•°: ${nonce}\n\n`;
                
                output += 'ç­¾åå­—ç¬¦ä¸²:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += `${signString}\n\n`;
                
                output += 'ç”Ÿæˆçš„ç­¾å:\n';
                output += `  ${signature}\n\n`;
                
                output += 'ç­¾ååçš„URL:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += urlObj.href + '\n\n';
                
                output += 'ğŸ“‹ éªŒè¯æ­¥éª¤:\n';
                output += '1. æå–timestamp, nonce, signatureå‚æ•°\n';
                output += '2. æŒ‰å­—æ¯é¡ºåºæ’åˆ—å…¶ä»–å‚æ•°\n';
                output += `3. ä½¿ç”¨${algo}å’Œå¯†é’¥ç”Ÿæˆç­¾å\n`;
                output += '4. æ¯”è¾ƒç­¾åæ˜¯å¦ä¸€è‡´\n';
                output += '5. éªŒè¯timestampæ˜¯å¦è¿‡æœŸ\n';
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·12: Bloom Filteræ£€æµ‹
        function bloomFilterTest() {
            const urlsText = document.getElementById('bloomUrls').value;
            const result = document.getElementById('bloomResult');
            
            const urls = urlsText.split('\n').filter(url => url.trim());
            
            // ç®€å•Bloom Filteræ¨¡æ‹Ÿ
            const bloomSize = 1024; // ä½æ•°ç»„å¤§å°
            const hashFunctions = 3; // å“ˆå¸Œå‡½æ•°æ•°é‡
            
            let bloomFilter = new Array(bloomSize).fill(0);
            let results = [];
            
            // ç®€å•å“ˆå¸Œå‡½æ•°
            function hash1(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash << 5) - hash + str.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash) % bloomSize;
            }
            
            function hash2(str) {
                let hash = 5381;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash << 5) + hash + str.charCodeAt(i);
                }
                return Math.abs(hash) % bloomSize;
            }
            
            function hash3(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 7) - hash);
                }
                return Math.abs(hash) % bloomSize;
            }
            
            let output = 'ğŸŒ¸ Bloom Filter URLæ£€æµ‹\n\n';
            output += `URLæ•°é‡: ${urls.length}\n`;
            output += `Bloom Filterå¤§å°: ${bloomSize} bits\n`;
            output += `å“ˆå¸Œå‡½æ•°æ•°é‡: ${hashFunctions}\n\n`;
            
            output += 'å¤„ç†ç»“æœ:\n';
            output += 'â”€'.repeat(50) + '\n';
            
            let falsePositives = 0;
            let truePositives = 0;
            let falseNegatives = 0;
            
            urls.forEach((url, index) => {
                const h1 = hash1(url);
                const h2 = hash2(url);
                const h3 = hash3(url);
                
                // æ£€æŸ¥æ˜¯å¦å¯èƒ½åœ¨é›†åˆä¸­
                const mightExist = bloomFilter[h1] && bloomFilter[h2] && bloomFilter[h3];
                
                // æ£€æŸ¥æ˜¯å¦ç¡®å®å­˜åœ¨è¿‡
                const seenBefore = results.slice(0, index).some(r => r.url === url);
                
                if (mightExist && !seenBefore) {
                    falsePositives++;
                    output += `${index + 1}. âŒ è¯¯æŠ¥: ${url}\n`;
                } else if (mightExist && seenBefore) {
                    truePositives++;
                    output += `${index + 1}. âœ… å­˜åœ¨: ${url}\n`;
                } else if (!mightExist && seenBefore) {
                    falseNegatives++;
                    output += `${index + 1}. âŒ æ¼æŠ¥: ${url}\n`;
                } else {
                    output += `${index + 1}. â• æ–°å¢: ${url}\n`;
                    
                    // æ·»åŠ åˆ°Bloom Filter
                    bloomFilter[h1] = 1;
                    bloomFilter[h2] = 1;
                    bloomFilter[h3] = 1;
                }
                
                results.push({ url, h1, h2, h3, mightExist, seenBefore });
            });
            
            // ç»Ÿè®¡ä¿¡æ¯
            const addedCount = urls.length - falsePositives - truePositives;
            const fillRate = bloomFilter.filter(bit => bit === 1).length / bloomSize;
            
            output += '\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯:\n';
            output += 'â”€'.repeat(50) + '\n';
            output += `æ–°å¢URL: ${addedCount}\n`;
            output += `é‡å¤URL: ${truePositives}\n`;
            output += `è¯¯æŠ¥ç‡: ${(falsePositives / urls.length * 100).toFixed(2)}%\n`;
            output += `å¡«å……ç‡: ${(fillRate * 100).toFixed(2)}%\n\n`;
            
            // ç†è®ºè¯¯æŠ¥ç‡
            const theoreticalFP = Math.pow(fillRate, hashFunctions);
            output += `ç†è®ºè¯¯æŠ¥ç‡: ${(theoreticalFP * 100).toFixed(4)}%\n`;
            
            // åº”ç”¨åœºæ™¯
            output += '\nğŸ¯ Bloom Filteråº”ç”¨åœºæ™¯:\n';
            output += 'â”€'.repeat(50) + '\n';
            output += '1. æ¶æ„URLæ£€æµ‹\n';
            output += '2. é‡å¤å†…å®¹è¯†åˆ«\n';
            output += '3. ç¼“å­˜é¢„çƒ­\n';
            output += '4. çˆ¬è™«å»é‡\n';
            output += '5. åƒåœ¾é‚®ä»¶è¿‡æ»¤\n';
            
            result.textContent = output;
        }

        // å·¥å…·13: URLç†µå€¼åˆ†æ
        function analyzeEntropy() {
            const url = document.getElementById('entropyUrl').value || document.getElementById('masterUrl').value;
            const result = document.getElementById('entropyResult');
            
            try {
                const urlObj = new URL(url);
                const fullUrl = urlObj.href;
                
                // è®¡ç®—å­—ç¬¦é¢‘ç‡
                const freq = {};
                for (const char of fullUrl) {
                    freq[char] = (freq[char] || 0) + 1;
                }
                
                // è®¡ç®—é¦™å†œç†µ
                let entropy = 0;
                const length = fullUrl.length;
                
                for (const char in freq) {
                    const probability = freq[char] / length;
                    entropy -= probability * Math.log2(probability);
                }
                
                // è®¡ç®—æœ€å¤§å¯èƒ½ç†µ
                const maxEntropy = Math.log2(Object.keys(freq).length);
                
                // è®¡ç®—å‹ç¼©æ¯”ä¼°è®¡
                const compressionRatio = entropy / maxEntropy;
                
                let output = 'ğŸ“Š URLç†µå€¼åˆ†æ\n\n';
                output += `URL: ${fullUrl}\n`;
                output += `é•¿åº¦: ${length} å­—ç¬¦\n`;
                output += `å”¯ä¸€å­—ç¬¦: ${Object.keys(freq).length}\n\n`;
                
                output += 'ğŸ”¢ ç†µå€¼è®¡ç®—:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += `é¦™å†œç†µ: ${entropy.toFixed(4)} bits/å­—ç¬¦\n`;
                output += `æœ€å¤§ç†µ: ${maxEntropy.toFixed(4)} bits/å­—ç¬¦\n`;
                output += `ç†µæ¯”: ${(entropy / maxEntropy * 100).toFixed(2)}%\n`;
                output += `å‹ç¼©æ¯”ä¼°è®¡: ${compressionRatio.toFixed(4)}\n\n`;
                
                // å­—ç¬¦åˆ†å¸ƒåˆ†æ
                output += 'ğŸ“ˆ å­—ç¬¦åˆ†å¸ƒ (å‰20ä¸ª):\n';
                output += 'â”€'.repeat(50) + '\n';
                
                const sortedChars = Object.entries(freq)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 20);
                
                sortedChars.forEach(([char, count]) => {
                    const percentage = (count / length * 100).toFixed(2);
                    const bar = 'â–ˆ'.repeat(Math.round(percentage / 5));
                    const displayChar = char === ' ' ? 'â£' : 
                                      char === '\t' ? 'â†’' : 
                                      char === '\n' ? 'â†µ' : char;
                    
                    output += `${displayChar.padEnd(2)} (${count.toString().padEnd(3)}) ${percentage.padStart(6)}% ${bar}\n`;
                });
                
                // ç†µå€¼è§£é‡Š
                output += '\nğŸ“‹ ç†µå€¼è§£é‡Š:\n';
                output += 'â”€'.repeat(50) + '\n';
                output += 'é«˜ç†µURL (> 4.5 bits/char):\n';
                output += '  â€¢ å¯èƒ½åŒ…å«åŠ å¯†æ•°æ®\n';
                output += '  â€¢ å¯èƒ½åŒ…å«éšæœºæ ‡è¯†ç¬¦\n';
                output += '  â€¢ å¯èƒ½åŒ…å«æ•æ„Ÿä¿¡æ¯\n\n';
                
                output += 'ä¸­ç†µURL (3.0-4.5 bits/char):\n';
                output += '  â€¢ æ­£å¸¸å†…å®¹URL\n';
                output += '  â€¢ åŒ…å«å¤šç§å­—ç¬¦\n';
                output += '  â€¢ è‰¯å¥½çš„éšæœºæ€§\n\n';
                
                output += 'ä½ç†µURL (< 3.0 bits/char):\n';
                output += '  â€¢ é‡å¤æ¨¡å¼\n';
                output += '  â€¢ ç®€å•ç»“æ„\n';
                output += '  â€¢ å¯èƒ½å¯é¢„æµ‹\n';
                
                // å®‰å…¨åˆ†æ
                output += '\nğŸ”’ å®‰å…¨åˆ†æ:\n';
                output += 'â”€'.repeat(50) + '\n';
                if (entropy > 5) {
                    output += 'âš ï¸ é«˜ç†µURL - å¯èƒ½åŒ…å«æ•æ„Ÿæˆ–åŠ å¯†æ•°æ®\n';
                } else if (entropy < 2) {
                    output += 'âš ï¸ ä½ç†µURL - å¯èƒ½æ˜“äºé¢„æµ‹æˆ–é­å—æšä¸¾æ”»å‡»\n';
                } else {
                    output += 'âœ… ç†µå€¼æ­£å¸¸ - æ— æ˜æ˜¾å®‰å…¨é£é™©\n';
                }
                
                // å‹ç¼©æ½œåŠ›
                output += '\nğŸ’¾ å‹ç¼©æ½œåŠ›:\n';
                output += `ç†è®ºå‹ç¼©ç‡: ${(1 - compressionRatio) * 100}%\n`;
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // å·¥å…·14: å·®åˆ†URLåˆ†æ
        function diffURLs() {
            const url1 = document.getElementById('diffUrl1').value;
            const url2 = document.getElementById('diffUrl2').value;
            const result = document.getElementById('diffResult');
            
            try {
                const urlObj1 = new URL(url1);
                const urlObj2 = new URL(url2);
                
                let output = 'ğŸ”¬ å·®åˆ†URLåˆ†æ\n\n';
                output += `URL1: ${urlObj1.href}\n`;
                output += `URL2: ${urlObj2.href}\n\n`;
                
                // åˆ†æå·®å¼‚
                const components = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'username', 'password'];
                const diffs = [];
                const sames = [];
                
                for (const comp of components) {
                    const val1 = urlObj1[comp] || '(ç©º)';
                    const val2 = urlObj2[comp] || '(ç©º)';
                    
                    if (val1 === val2) {
                        sames.push(`${comp}: ${val1}`);
                    } else {
                        diffs.push({
                            component: comp,
                            value1: val1,
                            value2: val2,
                            diffType: classifyDiff(val1, val2)
                        });
                    }
                }
                
                // æ˜¾ç¤ºç›¸åŒéƒ¨åˆ†
                if (sames.length > 0) {
                    output += 'âœ… ç›¸åŒéƒ¨åˆ†:\n';
                    output += 'â”€'.repeat(50) + '\n';
                    sames.forEach(item => output += `  ${item}\n`);
                    output += '\n';
                }
                
                // æ˜¾ç¤ºå·®å¼‚éƒ¨åˆ†
                if (diffs.length > 0) {
                    output += 'ğŸ”€ å·®å¼‚éƒ¨åˆ†:\n';
                    output += 'â”€'.repeat(50) + '\n';
                    
                    diffs.forEach(diff => {
                        output += `${diff.component}:\n`;
                        output += `  URL1: ${diff.value1}\n`;
                        output += `  URL2: ${diff.value2}\n`;
                        output += `  ç±»å‹: ${diff.diffType}\n`;
                        output += '  '.repeat(40) + '\n';
                    });
                }
                
                // APIç‰ˆæœ¬æ£€æµ‹
                const versionDiff = detectAPIVersion(urlObj1.pathname, urlObj2.pathname);
                if (versionDiff) {
                    output += '\nğŸ”„ APIç‰ˆæœ¬æ£€æµ‹:\n';
                    output += 'â”€'.repeat(50) + '\n';
                    output += versionDiff + '\n';
                }
                
                // å‚æ•°å·®å¼‚åˆ†æ
                const paramDiffs = analyzeParams(urlObj1.search, urlObj2.search);
                if (paramDiffs) {
                    output += '\nğŸ“‹ å‚æ•°å·®å¼‚åˆ†æ:\n';
                    output += 'â”€'.repeat(50) + '\n';
                    output += paramDiffs + '\n';
                }
                
                // å®‰å…¨å½±å“åˆ†æ
                output += '\nğŸ”’ å®‰å…¨å½±å“åˆ†æ:\n';
                output += 'â”€'.repeat(50) + '\n';
                
                const securityImplications = [];
                
                // åè®®å·®å¼‚
                if (urlObj1.protocol !== urlObj2.protocol) {
                    if (urlObj1.protocol === 'http:' && urlObj2.protocol === 'https:') {
                        securityImplications.push('å®‰å…¨å‡çº§ (HTTP â†’ HTTPS)');
                    } else if (urlObj1.protocol === 'https:' && urlObj2.protocol === 'http:') {
                        securityImplications.push('âš ï¸ å®‰å…¨é™çº§ (HTTPS â†’ HTTP)');
                    }
                }
                
                // ä¸»æœºå·®å¼‚
                if (urlObj1.hostname !== urlObj2.hostname) {
                    securityImplications.push('è·¨åŸŸè¯·æ±‚ - éœ€è¦CORSéªŒè¯');
                }
                
                // è·¯å¾„éå†æ£€æŸ¥
                if (urlObj1.pathname.includes('..') || urlObj2.pathname.includes('..')) {
                    securityImplications.push('âš ï¸ å¯èƒ½çš„è·¯å¾„éå†');
                }
                
                if (securityImplications.length > 0) {
                    securityImplications.forEach(imp => output += `  â€¢ ${imp}\n`);
                } else {
                    output += '  âœ… æ— æ˜æ˜¾å®‰å…¨å½±å“\n';
                }
                
                // å»ºè®®
                output += '\nğŸ’¡ å»ºè®®:\n';
                output += 'â”€'.repeat(50) + '\n';
                if (diffs.length > 3) {
                    output += '1. è€ƒè™‘URLæ ‡å‡†åŒ–\n';
                    output += '2. å®æ–½ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥\n';
                    output += '3. ç›‘æ§URLæ¨¡å¼å˜åŒ–\n';
                } else {
                    output += '1. å·®å¼‚è¾ƒå°ï¼Œå¯è€ƒè™‘åˆå¹¶\n';
                    output += '2. ç¡®ä¿å‘åå…¼å®¹\n';
                }
                
                result.textContent = output;
                
            } catch (e) {
                result.textContent = 'é”™è¯¯: ' + e.message;
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šåˆ†ç±»å·®å¼‚ç±»å‹
        function classifyDiff(val1, val2) {
            if (!val1 && val2) return 'æ–°å¢';
            if (val1 && !val2) return 'åˆ é™¤';
            if (val1.length !== val2.length) return 'é•¿åº¦å˜åŒ–';
            if (val1.toLowerCase() === val2.toLowerCase()) return 'å¤§å°å†™å˜åŒ–';
            if (encodeURI(val1) === encodeURI(val2)) return 'ç¼–ç å·®å¼‚';
            return 'å†…å®¹å˜åŒ–';
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ£€æµ‹APIç‰ˆæœ¬
        function detectAPIVersion(path1, path2) {
            const versionPattern = /\/v(\d+)\//g;
            const match1 = path1.match(versionPattern);
            const match2 = path2.match(versionPattern);
            
            if (match1 && match2 && match1[0] !== match2[0]) {
                return `APIç‰ˆæœ¬å˜åŒ–: ${match1[0]} â†’ ${match2[0]}`;
            }
            return null;
        }

        // è¾…åŠ©å‡½æ•°ï¼šåˆ†æå‚æ•°å·®å¼‚
        function analyzeParams(search1, search2) {
            const params1 = new URLSearchParams(search1);
            const params2 = new URLSearchParams(search2);
            
            const added = [];
            const removed = [];
            const changed = [];
            
            // æ£€æŸ¥æ–°å¢å‚æ•°
            for (const [key, val2] of params2) {
                if (!params1.has(key)) {
                    added.push(`${key}=${val2}`);
                }
            }
            
            // æ£€æŸ¥åˆ é™¤çš„å‚æ•°
            for (const [key, val1] of params1) {
                if (!params2.has(key)) {
                    removed.push(`${key}=${val1}`);
                }
            }
            
            // æ£€æŸ¥å˜åŒ–çš„å‚æ•°
            for (const [key, val1] of params1) {
                const val2 = params2.get(key);
                if (val2 !== null && val1 !== val2) {
                    changed.push(`${key}: ${val1} â†’ ${val2}`);
                }
            }
            
            let result = '';
            if (added.length > 0) result += `æ–°å¢å‚æ•°: ${added.join(', ')}\n`;
            if (removed.length > 0) result += `åˆ é™¤å‚æ•°: ${removed.join(', ')}\n`;
            if (changed.length > 0) result += `å˜åŒ–å‚æ•°: ${changed.join(', ')}\n`;
            
            return result || null;
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.onload = function() {
            document.getElementById('masterUrl').focus();
        };
    </script>
</body>
</html>